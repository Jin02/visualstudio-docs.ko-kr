---
title: Visual Studio 용 응용 프로그램 패턴 | Microsoft Docs
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: gregvanl
ms.author: gregvanl
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: fd12d18c0230af4307d0dec8fe37868801226472
ms.sourcegitcommit: 1fc6ee928733e61a1f42782f832ead9f7946d00c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/22/2019
ms.locfileid: "60090779"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio 용 응용 프로그램 패턴
## <a name="BKMK_WindowInteractions"></a> 창의 상호 작용

### <a name="overview"></a>개요
두 개의 주 창 Visual Studio에서 사용 되는 형식은 문서 편집기 및 도구 창입니다. 드물지만 가능 하면 큰 모덜리스 대화 상자는입니다. 이러한 옵션은 셸에서 모든 모덜리스, 해당 패턴은 근본적으로 다릅니다. 이 섹션에서는 문서 창과 도구 창, 모덜리스 대화 상자 간의 차이점을 설명 합니다. 모달 대화 패턴에서 다루어진 [대화 상자](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)합니다.

### <a name="comparing-window-usage-patterns"></a>비교 창 사용 패턴
**문서 창** 거의 항상 내에 표시 되는 문서도 합니다. 이 통해 문서 편집기 "center 단계" 관련 추가 도구 창 정렬 합니다.

A **도구 창** 가장 자주 축소 IDE의 가장자리에 대해 별도, 더 작은 창으로 표시 됩니다. 표시, 숨김, 또는 자동으로 숨길 수 있습니다. 그러나 경우에 따라 도구 창 표시 됩니다는 물론 문서 내에서 선택을 취소 하 여 합니다 **도킹창/** 속성 창에서. 이 자세한 부동산 줄어들지만 일반적인 설계 결정 사항: Visual Studio 통합을 하려고 하면 기능 도구 창이 나 문서 창을 표시할 것인지 여부를 결정 해야 합니다.

**모덜리스 대화 상자** 않는 Visual Studio에서 것이 좋습니다. 가장 모덜리스 대화 상자 부동 정의 따라 인 도구 창 및 이런 방식으로 구현 해야 합니다. 모덜리스 대화 상자는 셸의 쪽에 도킹 된 일반 도구 창의 크기는 너무 제한 하는 경우 허용 됩니다. 사용자 대화 상자를 보조 모니터 이동할 가능성이 수 없는 경우에도 허용 됩니다.

신중 하 게는 컨테이너 형식에 대 한 해야 한다고 생각 합니다. 다음 표에서이 있는 UI 디자인에 대 한 일반적인 사용 패턴 고려 사항입니다.

||문서 창|도구 창|모덜리스 대화 상자|
|-|---------------------|-----------------|---------------------|
| **위치** | 항상 문서 내에 배치 하 고 IDE의 가장자리에 도킹 되지 않습니다. 이 "뺄 수" 주 셸에서 별도로 부동 합니다. | 일반적으로 탭 도킹 IDE의 가장자리 주위 하지만 수를 부동 수는 사용자 지정, 자동 숨김 (고정 해제 됨), 또는 잘 문서 내에서 도킹 합니다.|IDE에서 별도 큰 부동 창 |
| **모델을 커밋** | *지연 된 커밋*<br /><br /> 사용자 문서에서 데이터를 저장 하기 위해 실행 해야 합니다는 **파일 &gt; 저장**를 **이름으로 저장**, 또는 **모두 저장** 명령입니다. 문서 창에는 저장 중에 커밋된 다음 되 고 "정리" 그 내부의 데이터가 개념이 있습니다. 명령입니다. 문서 창을 닫으면이 모든 콘텐츠는 디스크에 저장 또는 손실 합니다. | *즉시 커밋*<br /><br /> 저장 하지는 모델입니다. 파일 편집에 도움이 되는 검사기 도구 창, 파일 활성 편집기 또는 디자이너에 열려 있어야 하며 편집기 또는 디자이너를 소유 저장 합니다. | *연기 또는 즉시 커밋*<br /><br /> 대부분의 경우 큰 모덜리스 대화 상자는 변경 내용을 커밋하기 위해 동작을 필요로 하 고 대화 세션 내에서 수행 된 모든 변경 내용이 롤백됩니다 "취소" 작업을 허용 합니다.  이 도구 창에는 항상 즉시 커밋 모델이 없는 도구 창에서 모덜리스 대화 상자를 구분 합니다. |
| **표시 유형** | *(파일)를 만들기/열기 및 닫기*<br /><br /> 문서 창 열기 기존 문서 열기 또는 템플릿을 사용 하 여 새 문서 만들기를 통해 이루어집니다. 방법이 없는 "열기 \<특정 편집기 >" 명령입니다. | *숨기기 및 표시*<br /><br /> 단일 인스턴스 도구 창은 숨기 거 나 표시 될 수 있습니다. 콘텐츠 및 도구 창 내에서 상태 저장 여부를 표시 또는 숨김입니다. 다중 인스턴스 도구 창 수 수 닫을 뿐만 아니라 숨겨집니다. 다중 인스턴스 도구 창이 닫힐 때 콘텐츠 및 상태 도구 창 내에서 삭제 됩니다. | *명령에서 시작*<br /><br /> 대화 상자는 작업 기반 명령에서 시작 됩니다. |
| **인스턴스** | *다중 인스턴스*<br /><br /> 일부 편집기도 동일한 파일을 둘 이상 편집기에서 열기를 허용 하는 동안 여러 편집기 동일한 시간 및 다른 파일을 편집한에 개방 될 수 있습니다 (사용 하 여 합니다 **창을 &gt; 새 창** 명령).<br /><br /> 동시 (프로젝트 디자이너) 단일 편집기는 하나 이상의 파일 편집 될 수 있습니다. | *단일 또는 다중 인스턴스*<br /><br /> 콘텐츠 (예: 속성 브라우저) 상황에 맞는 반영 또는 (작업 목록, 솔루션 탐색기) 다른 창에 포커스/컨텍스트 푸시를 변경 합니다.<br /><br /> 단일 인스턴스 및 다중 인스턴스 도구 창 없는 중요 한 이유가 있지에 활성 문서 창과 사용 하 여 연결 해야 합니다. | *Single-instance* |
| **예제** | **텍스트 편집기**, 코드 편집기와 같은<br /><br /> **디자인 화면을**폼 디자이너 또는 모델링 화면 등<br /><br /> **대화 상자에 유사한 레이아웃을 제어**, 매니페스트 디자이너와 같은 | 합니다 **솔루션 탐색기** 솔루션 내에 포함 된 프로젝트 및 솔루션을 제공 합니다.<br /><br /> 합니다 **서버 탐색기** 창에서 열려는 사용자가 서버 및 데이터 연결의 계층적 뷰를 제공 합니다. 쿼리를 같은 데이터베이스 계층에서 개체를 열고 문서 창이 열리고 쿼리를 편집할 수 있습니다.<br /><br /> 합니다 **속성 브라우저** 문서 창 또는 다른 도구 창에서 선택한 개체에 대 한 속성이 표시 됩니다. 계층적 표 뷰 또는 복잡 한 대화 상자와 비슷한 컨트롤에 표시 됩니다 속성과 이러한 속성에 대 한 값을 설정 하는 데 사용할 수 있습니다. | |

## <a name="BKMK_ToolWindows"></a> 도구 창

### <a name="overview"></a>개요
도구 창은 문서 창에서 발생 하는 사용자의 작업을 지원 합니다. Visual Studio를 제공 하 고 조작할 수 있는 기본 루트 개체를 나타내는 계층 구조를 표시할 수 있습니다.

새 도구 창을 IDE 고려할 때 작성자가 수행 해야 합니다.

- 기존 도구 창을 작업에 적절 한 사용 및 유사한 기능을 사용 하 여 새 계정을 만들지는 합니다. 새 도구 창은 크게 다른 "도구" 또는 유사한 창으로 또는 기존 창을 피벗 허브로 설정 하 여 통합 될 수 없습니다 하는 기능을 제공 하는 경우에 생성 해야 합니다.

- 필요에 따라 도구 창의 맨 위에 있는 표준 명령 모음을 사용 합니다.

- 컨트롤 프레젠테이션 및 키보드 탐색을 위한 다른 도구 창에 이미 있는 패턴을 사용 하 여 일관 되어야 합니다.

- 다른 도구 창에 컨트롤 표시를 사용 하 여 일관 되어야 합니다.

- 확인 문서 관련 도구 창 자동 표시 가능한 경우 부모 문서를 활성화 하는 경우에 표시 되도록 합니다.

- 키보드 (지원 화살표 키)를 사용 하는 탐색 가능한 창 콘텐츠를 확인 합니다.

#### <a name="tool-window-states"></a>도구 창 상태
Visual Studio 도구 창은 일부 (예: 자동 숨기기 기능) 사용자 활성화는 다양 한 상태의 경우 다른 상태를 자동 표시와 같은, 올바른 컨텍스트에서 표시 되 고 필요 하지 않을 때 숨길 도구 창을 허용 합니다. 총에서 5 개의 도구 창 상태가 있습니다.

- **고정/고정** 도구 창을 문서 영역의 네 면 중 하나에 연결할 수 있습니다. 도구 창 제목 표시줄에 압정 아이콘으로 표시 됩니다. 도구 창을 셸 및 기타 도구 창을의 가장자리를 따라 가로 또는 세로로 도킹 될 및 탭으로 연결할 수도 있습니다.

- **자동으로 숨겨진** 도구 창을 고정 해제 됩니다. 창 (포함 된 도구 창 및 해당 아이콘의 이름) 탭 문서 영역의 가장자리를 두면 보이지 않도록 슬라이드 할 수 있습니다. 사용자가 탭을 마우스로 가리킬 때 도구 창을 아웃 슬라이드 합니다.

- **자동 표시** 편집기와 같은 UI의 다른 부분 프로그램이 시작 되거나 포커스를 획득 하는 경우에 자동으로 도구 창을 표시 합니다.

- **부동** 도구 창을 IDE 외부에서 이동 합니다. 다중 모니터 구성에 유용합니다.

- **탭된 문서** 도구 창은 문서 내에서 잘 도킹 될 수 있습니다. 이 허용 되는 프레임의 가장자리에 도킹 보다 자세한 부동산 해야 하는 개체 브라우저와 같은 많은 도구 창에 유용 합니다.

![Visual Studio에서 창 상태 도구](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702 01_ToolWindowStates")<br />Visual Studio의 도구 창 상태

#### <a name="single-instance-and-multi-instance"></a>단일 인스턴스 및 다중 인스턴스
도구 창에는 단일 인스턴스 또는 다중 인스턴스입니다. 일부 단일 인스턴스 도구 창 않을 다중 인스턴스 도구 창 동안 활성 문서 창과 사용 하 여 연결 수 있습니다. 다중 인스턴스 도구 창에 응답 합니다 **창을 &gt; 새 창** 창의 새 인스턴스를 만들어 명령을 합니다. 다음 이미지에서는 창의 인스턴스 활성화 된 경우 새 창 명령을 사용 하도록 설정 하면 도구 창을 보여 줍니다.

![' 새 창 ' 명령 창의 인스턴스를 사용 하도록 설정 하는 도구 창이 활성 상태일](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702 02_ToolWindowEnablingCommand")<br />창의 인스턴스 활성화 된 경우 ' 새 창 ' 명령을 사용 하도록 설정 하는 도구 창

단일 인스턴스 도구 창은 숨기 거 나 표시, 다중 인스턴스 도구 창 수 수 닫을 뿐만 아니라 숨겨진 동안 수 수 있습니다. 모든 도구 창은 도킹할 수 탭 연결, 부동 또는 다중 문서 MDI (인터페이스) 자식 창 (문서 창 유사)으로 설정 합니다. 모든 도구 창은 창 메뉴에 해당 하는 창 관리 명령에 응답 해야 합니다.

![Visual Studio 창 메뉴의 창 관리 명령](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702 03_WindowManagementControls")<br />Visual Studio 창 메뉴의 창 관리 명령

#### <a name="document-specific-tool-windows"></a>문서 관련 도구 창
일부 도구 창은 문서의 지정된 된 형식에 따라 변경 하도록 설계 되었습니다. 이러한 창은 IDE의 현재 문서 창에 해당 하는 기능을 반영 하도록 지속적으로 업데이트 합니다.

선택한 편집기를 반영 하도록 변경 내용이 도구 창의 예로 도구 및 문서 개요를 들 수 있습니다. 이러한 windows 편집기에 포커스가 창에는 컨텍스트를 제공 하지 않는 경우 워터 마크를 표시 합니다.

#### <a name="navigable-list-tool-windows"></a>탐색 가능한 목록 도구 창
일부 도구 창에는 사용자가 상호 작용할 수 있습니다 하는 탐색 가능한 항목 목록을 표시 합니다. 이 유형의 창에서는 항상 없어야 목록의 현재 항목에 대 한 피드백을 창이 활성화 되지 않은 경우에 합니다. 목록에 응답 해야 합니다 **GoToNextLocation** 하 고 **GoToPrevLocation** 도 창에서 현재 선택된 된 항목을 변경 하 여 명령

탐색 가능한 목록 도구 창의 예로 찾기 결과 창과 솔루션 탐색기를 들 수 있습니다.

### <a name="tool-window-types"></a>도구 창 유형

#### <a name="common-tool-windows-and-their-functions"></a>일반적인 도구 창 및 해당 기능

**계층 구조 도구 창**

| 도구 창 | 함수 |
| --- | --- |
| 솔루션 탐색기 | 솔루션 항목 프로젝트, 기타 파일에 포함 된 문서 목록을 표시 하는 계층적 트리. 프로젝트 내에서 항목의 표시는 프로젝트 형식 (예를 들어 참조 기반, 디렉터리 기반 또는 혼합 형식)를 소유 하는 패키지에 의해 정의 됩니다. |
| 클래스 뷰 | 클래스 및 문서 파일 자체의 독립의 작업 집합에서 다양 한 요소의 계층적 트리. |
| 서버 탐색기 | 솔루션의 모든 서버 및 데이터 연결을 표시 하는 계층적 트리. |
| 문서 개요 | 활성 문서의 계층 구조입니다. |

**표 도구 창**

| 도구 창 | 함수 |
| --- | --- |
| 속성 | 이러한 속성을 편집 하려면 값 선택기와 함께 선택한 개체에 대 한 속성의 목록을 표시 하는 표입니다. |
| 작업 목록 | 사용자 만들기/편집/삭제 작업 및 메모를 허용 하는 표입니다. |

**콘텐츠 도구 창**

| 도구 창 | 함수 |
| --- | --- |
| Help | 사용자의 "방법"에서 도움을 받을 수 있는 다양 한 메서드에 대 한 액세스를 허용 하는 창 MSDN 포럼 비디오입니다. |
| 동적 도움말 | 도움말 항목을 현재 선택 영역에 적용할 수에 대 한 링크를 표시 하는 도구 창입니다. |
| 개체 브라우저 | 왼쪽된 창에서 개체의 속성 계층 개체 구성 요소 목록과 오른쪽 열에는 메서드를 사용 하 여 두 개의 열 프레임셋 합니다. |

**대화 상자 도구 창**

| 도구 창 | 함수 |
| --- | --- |
| Find | 사용자 찾기 또는에서 찾기 및 바꾸기 솔루션 내에서 다양 한 파일에 있는 대화 상자. |
| 상세하게 찾기 | 사용자 찾기 또는에서 찾기 및 바꾸기 솔루션 내에서 다양 한 파일에 있는 대화 상자. |

**다른 도구 창**

::: moniker range="vs-2017"

| 도구 창 | 함수 |
| --- | --- |
| 도구 상자 | 모든 디자이너에 대 한 일관성 있는 끌기 소스를 제공 하는 디자인 표면에서 삭제 될 요소를 저장 하는 데 사용 되는 도구 창입니다. |
| 시작 페이지 | 피드 전자 메일로 개발자 소식, Visual Studio 도움말 및 최근에 사용한 프로젝트에 대 한 액세스를 사용 하 여 Visual Studio로 사용자의 포털입니다. 사용자에서 StartPage.xaml 파일을 복사 하 여 사용자 지정 시작 페이지를 만들 수도 있습니다는 "Common7\IDE\StartPages\" StartPages 폴더는 Visual Studio에 Visual Studio 프로그램 파일 디렉터리 디렉터리 및 다음 편집 하거나의 XAML 문서 직접 또는 Visual Studio 또는 다른 코드 편집기에서 열기. |

::: moniker-end

::: moniker range=">=vs-2019"

| 도구 창 | 함수 |
| --- | --- |
| 도구 상자 | 모든 디자이너에 대 한 일관성 있는 끌기 소스를 제공 하는 디자인 표면에서 삭제 될 요소를 저장 하는 데 사용 되는 도구 창입니다. |

::: moniker-end

**디버거 도구 창**

| 도구 창 | 함수 |
| --- | --- |
| 자동 ||
| 직접 실행 ||
| 출력 | 출력 창 텍스트 이벤트 또는 상태 선언할 수 있을 때마다 사용할 수 있습니다. |
| 메모리 ||
| 중단점 ||
| 실행 중 ||
| 문서 ||
| 호출 스택 ||
| 로컬 ||
| 조사식 ||
| 디스어셈블리 ||
| 레지스터 ||
| 스레드 ||

## <a name="BKMK_DocumentEditorConventions"></a> 편집기 도움말 표기법

### <a name="document-interactions"></a>문서 상호 작용
"문서 도" IDE 내에서 가장 큰 공간 이며 여기서 사용자 일반적으로 초점을 맞춘 주의가 지원 추가 도구 창에서 작업을 완료 하기 위해입니다. 문서 편집기는 사용자가 열리고 Visual Studio 내에서 저장 하는 작업의 기본 단위를 나타냅니다. 솔루션 탐색기 또는 다른 활성 계층 구조 창에 연결 된 선택의 강력한 개념이 유지 됩니다. 사용자는 해당 계층 구조 창 중 하나를 가리키고 솔루션, 프로젝트 또는 Visual Studio 패키지에서 제공 하는 다른 루트 개체에 문서가 포함 된 위치 및 해당 관계를 알고 있어야 합니다.

문서 편집 일관 된 사용자 경험에 필요합니다. 사용자는 작업에 대신 명령을 찾아 창 관리에 집중할 수 있도록 해당 문서 유형을 편집에 대 한 사용자 작업에 가장 적합 한 문서 뷰 전략을 선택 합니다.

#### <a name="common-interactions-for-the-document-well"></a>문서 저장소에 대 한 일반적인 상호 작용

- 일반적인에서 일관 된 상호 작용 모델을 유지 **새 파일** 하 고 **열려 있는 파일** 환경.

- 문서 창이 열리면 관련된 창 및 메뉴에서 관련된 기능을 업데이트 합니다.

- 와 같은 일반적인 메뉴에 메뉴 명령을 적절 하 게 통합 **편집할**, **형식**, 및 **뷰** 메뉴. 상당한 양의 특수 명령을 사용할 수 있으면 새 메뉴를 만들 수 있습니다. 이 새 메뉴는 문서에 포커스가 있을 때에 표시 되어야 합니다.

- 포함된 된 도구 모음 편집기의 맨 위에 있는 배치 될 수 있습니다. 이 별도 도구 모음 편집기 외부에서 표시 되는 것이 낫습니다.

- 솔루션 탐색기 또는 유사한 활성 선택 영역을 항상 유지 계층 구조 창입니다.

- 솔루션 탐색기에서 문서를 두 번 클릭 하면 동일한 작업을 수행 해야 **열려**합니다.

- 문서 형식에 둘 이상의 편집기를 사용할 수 있는 경우 사용자 있으려면 재정의 하거나 사용 하 여 지정 된 문서 형식에서 기본 작업을 다시 설정 합니다 **연결** 파일을 마우스 오른쪽 단추로 클릭 하 고 선택 하 여 대화 상자 **열기 사용 하 여** 바로 가기 메뉴에서.

- 문서에서 마법사를 잘 빌드하지 마세요.

### <a name="user-expectations-for-specific-document-types"></a>특정 문서 유형에 대 한 사용자의 기대
몇 가지 기본 유형의 문서 편집기 되며 각 집합이 동일한 형식의 다른 사용자와 일치 하는 상호 작용 합니다.

- **텍스트 기반 편집기:** 코드 편집기, 로그 파일

- **디자인 화면:** WPF 폼 디자이너에서 Windows forms

- **대화 상자 스타일 편집기:** 매니페스트 디자이너, 프로젝트 속성

- **모델 디자이너:** codemap, 워크플로 디자이너, 아키텍처 다이어그램, 진행

비 편집기 유형은 문서를 사용 하는 몇 가지가 있습니다. 문서 자체를 편집 하지 하는 동안 문서 창에 대 한 표준 상호 작용 필요가 없습니다.

- **보고서:** IntelliTrace 보고서, 하이퍼-V 보고서, 프로파일러 보고서

- **대시보드:** 진단 허브

#### <a name="text-based-editors"></a>텍스트 기반 편집기

- 문서를 열지 않고도 문서를 미리 볼 수 있도록 미리 보기 탭 모델에 참여 합니다.

- 문서 개요 등의 도우미 도구 창 내에서 문서 구조를 나타낼 수 있습니다.

- IntelliSense (해당 하는 경우)는 다른 코드 편집기를 사용 하 여 일관 되 게 작동 합니다.

- 팝업 또는 보조 UI CodeLens와 같은 기존 유사한 UI에 대 한 유사한 스타일 및 패턴을 따릅니다.

- 상태 표시줄에 또는 문서의 맨 위에 있는 정보 표시줄 컨트롤에서 문서 상태에 대 한 메시지가 표시 됩니다.

- 사용자는 글꼴 및 색을 사용 하 여 모양을 사용자 지정할 수 있어야 합니다.는 **도구 > 옵션** 공유 글꼴 및 색 페이지 또는 특정 편집기 페이지입니다.

#### <a name="design-surfaces"></a>디자인 화면

- 빈 디자이너를 시작 하는 방법을 나타내는 화면에 워터 마크를 사용 해야 합니다.

- 보기 전환 메커니즘은 코드 편집기를 열거나 창 모두와 상호 작용 허용 문서 창 내 탭을 두 번 클릭과 같은 기존 패턴을 따릅니다.

- 디자인 화면에 요소를 추가 해야 도구 상자를 통해 항상 특정 도구 창 필요한 경우를 제외 합니다.

- 화면에서 항목 선택 일관 된 모델을 따릅니다.

- 포함 된 도구 모음 같은 문서 관련 명령만, 일반적인 명령이 포함 되어 **저장할**합니다.

#### <a name="dialog-style-editors"></a>대화 상자 스타일 편집기

- 컨트롤 레이아웃 일반 대화 상자 레이아웃 규칙을 따라야 합니다.

- 편집기 내에서 탭 문서 탭의 모양을 일치 해서는 안, 허용 된 내부 탭 두 스타일 중 하나를 일치 해야 합니다.

- 사용자만; 키보드를 사용 하 여 컨트롤과 상호 작용할 수 있어야 합니다. 하거나 표준 니모닉을 사용 하 여 편집기를 활성화 및 컨트롤을 통해 또는 탭 합니다.

- 디자이너는 일반 모델 저장을 사용 해야 합니다. 다른 단추 적절할 수 있지만 전체 저장 없거나 커밋 단추를 화면에 배치 되어야 합니다.

#### <a name="model-designers"></a>모델 디자이너

- 빈 디자이너를 시작 하는 방법을 나타내는 화면에 워터 마크를 사용 해야 합니다.

- 디자인 화면에 요소를 추가 하는 도구 상자를 통해 수행 되어야 합니다.

- 화면에서 항목 선택 일관 된 모델을 따릅니다.

- 포함 된 도구 모음 같은 문서 관련 명령만, 일반적인 명령이 포함 되어 **저장할**합니다.

- 범례는 암시적 또는 워터 마크를 화면에 나타날 수 있습니다.

- 사용자를 사용 하 여 글꼴 및 색의 모양을 사용자 지정할 수 있어야 합니다.는 **도구 > 옵션** 공유 글꼴 및 색 페이지 또는 특정 편집기 페이지입니다.

#### <a name="reports"></a>보고서

- 보고서는 일반적으로 정보 전용 및 모델 저장에에서 참여 하지 않습니다. 그러나 다른 관련 정보 또는 확장 및 축소 하는 섹션에 대 한 링크와 같은 상호 작용을 포함 될 수 있습니다.

- 화면에서 대부분의 명령은 하이퍼링크 단추 하지 해야 합니다.

- 레이아웃 헤더를 포함 하 고 표준 보고서 레이아웃 지침을 수행 해야 합니다.

#### <a name="dashboards"></a>대시보드

- 대시보드는 상호 작용 모델 자체에 없지만 다양 한 다른 도구를 제공 하는 수단으로 사용.

- 모델 저장에에서는 참여 하지 않습니다.

- 사용자는 편집기를 활성화 하 여 컨트롤에서 tab 키 또는 표준 니모닉을 사용 하 여만 키보드를 사용 하 여 컨트롤과 상호 작용할 수 있어야 합니다.

## <a name="BKMK_Dialogs"></a> 대화 상자

### <a name="introduction"></a>소개
Visual Studio에서 대화 상자 일반적으로 한 개별 사용자의 작업 단위를 지원 해야 및 해제 합니다.

대화 상자를 사용 해야 한다는 결정 하는 경우 세 가지 옵션이 있습니다, 우선 순위에서:

1. Visual Studio의 공유 대화 상자 중 하나에 기능을 통합 합니다.

2. 기존 비슷한 대화 상자에서 발견 되는 패턴을 사용 하 여 고유한 대화 상자를 만듭니다.

3. 새 대화 상자, 다음 상호 작용 및 레이아웃 지침을 만듭니다.

이 섹션에서는 Visual Studio 워크플로 내의 올바른 대화 패턴 및 대화 상자 디자인에 대 한 일반적인 규칙을 선택 하는 방법을 설명 합니다.

### <a name="themes"></a>테마
Visual Studio에서 대화 상자는 두 가지 기본 스타일 중 하나를 따르십시오.

#### <a name="standard-unthemed"></a>표준 (unthemed)
대부분의 대화 상자 표준 유틸리티 대화 상자 이며 unthemed 이어야 합니다. 스타일이 적용 된 "최신" 단추 또는 컨트롤을 만들려고 시도 하거나 템플릿을 다시 만들면 공용 컨트롤 하지 마십시오. 컨트롤 및 chrome 모양을 따릅니다 [대화 상자에 대 한 표준 Windows 데스크톱 상호 작용 지침](/windows/desktop/uxguide/win-dialog-box)합니다.

#### <a name="themed"></a>테마가 지정 된
전문 "서명" 대화 상자는 테마가 지정 된 수 있습니다. 테마가 지정 된 대화 상자에 고유한 모양을 스타일으로 관련 된 몇 가지 특별 한 상호 작용 패턴에도 있는 경우 테마 이러한 요구 사항을 충족 하는 경우에 대화 상자:

- 대화 상자는 표시 되 고 종종 또는 많은 사용자를 사용 하는 일반적인 환경 (예를 들어 합니다 **새 프로젝트** 대화 합니다.

- 주요 제품 브랜드 요소를 포함 하는 대화 상자 (예를 들어 합니다 **계정 설정** 대화).

- 테마가 지정 된 다른 대화 상자를 포함 하는 보다 큰 흐름의 필수적인 부분으로 된 대화 상자가 나타납니다 (예를 들어 합니다 **연결 된 서비스 추가** 대화).

- 대화 상자는 전략적 한 역할을 승격 하거나 제품 버전을 구분 하는 환경에서의 중요 한 부분입니다.

테마가 지정 된 대화 상자를 만들 때 적절 한 환경 색을 사용 하 고 올바른 레이아웃 및 상호 작용 패턴을 따릅니다. (참조 [Visual Studio에 대 한 레이아웃](../../extensibility/ux-guidelines/layout-for-visual-studio.md).)

### <a name="dialog-design"></a>대화 상자 디자인
잘 디자인 된 대화 상자는 다음 요소가 고려해 야 합니다.

- 지원 되는 사용자 작업

- 대화 상자 텍스트 스타일, 언어 및 용어

- 컨트롤 선택 및 UI 규칙

- 시각적 레이아웃 사양 및 컨트롤 맞춤

- 키보드 액세스

#### <a name="content-organization"></a>콘텐츠 구성
대화 상자의 이러한 기본 형식 간의 차이점을 고려해 야 합니다.

- [간단한 대화 상자](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 하나의 모달 창에서 컨트롤을 제공 합니다. 표시 필드 선택기 또는 아이콘 표시줄을 포함 하 여 복잡 한 컨트롤 패턴의 변형을 포함할 수 있습니다.

- [대화 상자를 계층화](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) 는 단일 UI 컨트롤의 여러 그룹을 구성 하는 경우 화면 자원을 최대한 활용 하기 위해 사용 됩니다. 대화 상자의 그룹 "계층화 되어" 탭 컨트롤, 탐색 목록 컨트롤 또는 단추를 통해 사용자는 언제 든 보려면 그룹화를 선택할 수 있도록 합니다.

- [마법사](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 작업의 완료 될 때까지 단계의 논리적 시퀀스를 통해 사용자를 전달 하는 데 유용 합니다. 여러 선택 항목은 경우에 따라 다른 워크플로 ("분기") 선택을 이전 패널에서 종속를 소개 하는 순차적 패널에 제공 됩니다.

#### <a name="BKMK_SimpleDialogs"></a> 간단한 대화 상자
간단한 대화는 하나의 모달 창에서 컨트롤 표시. 이 프레젠테이션에서 다양 한 필드 선택기와 같은 복잡 한 컨트롤 패턴을 포함할 수 있습니다. 간단한 대화 상자에 대 한 표준 일반 레이아웃 뿐만 아니라 복잡 한 제어 그룹화 하는 데 필요한 모든 특정 레이아웃을 수행 합니다.

![> 만들기 강력한 이름 키는 Visual Studio에서 간단한 대화 상자의 예입니다. ](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704 01_CreateStrongNameKey")<br />만들 강력한 이름 키는 Visual Studio에서 간단한 대화 상자의 예입니다.

#### <a name="BKMK_LayeredDialogs"></a> 계층화 된 대화 상자
계층화 된 대화 상자 탭, 대시보드 및 포함 된 트리를 포함 합니다. UI의 한 부분에서 제공 되는 컨트롤의 여러 그룹에 있을 때 부동산을 최대화 하기 위해 사용 됩니다. 사용자는 한 번에 보려면 그룹화를 선택할 수 있도록 그룹화 계층화 됩니다.

가장 간단한 경우 그룹 간 전환을 위한 메커니즘에는 탭 컨트롤입니다. 사용할 수 있는 몇 가지 대안이 있습니다. Prioritizing 및 가장 적합 한 스타일을 선택 하는 방법에 대 한 레이어를 참조 하세요.

합니다 **도구가 &gt; 옵션** 대화 상자는 포함 된 트리를 사용 하 여 계층화 된 대화의 예제는:

![도구 > 옵션은 Visual Studio에서 계층화 된 대화 상자의 예입니다. ](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704 02_ToolsOptions")<br />도구 > 옵션은 Visual Studio에서 계층화 된 대화 상자의 예입니다.

#### <a name="BKMK_Wizards"></a> 마법사
마법사 완료 시 작업 단계의 논리적 시퀀스를 통해 사용자를 전달 하는 데 유용 합니다. 여러 선택 항목을 순차적 패널을 제공 하 고 사용자는 다음 단계로 진행 하기 전에 각 단계를 계속 진행 해야 합니다. 충분 한 기본값을 사용할 수 있으면 합니다 **완료** 단추가 활성화 됩니다.

 모달 마법사 작업에 사용 되는:

- 서로 다른 경로 사용자 선택에 따라 제공 되는 분기 포함

- 후속 단계 이전 단계에서 사용자 입력에 따라 달라 집니다 단계 간의 종속성을 포함 합니다.

- 제공 된 선택 사항 및 각 단계에서 가능한 결과 설명 하는 UI를 사용 해야 함을 충분히 복잡 한

- 트랜잭션, 모든 변경 내용이 커밋되기 전에 전체에 완료할 수 있도록 단계 집합이 필요 합니다.

### <a name="common-conventions"></a>공통 규칙
최적의 디자인 및 사용자 대화 상자를 사용 하 여 기능을 얻으려면 대화 상자 크기, 위치, 표준, 제어 구성 및 맞춤, UI 텍스트, 제목 표시줄, 컨트롤 단추 및 액세스 키에서 이러한 규칙을 따릅니다.

레이아웃에 따른 지침을 참조 하세요 [Visual Studio에 대 한 레이아웃](../../extensibility/ux-guidelines/layout-for-visual-studio.md)합니다.

#### <a name="size"></a>크기
대화 상자를 최소 1024 x 768 이상의 화면 해상도, 내에 맞춰지는지 및 초기 대화 상자 크기가 900 개의 700mhz 픽셀을 넘지 않아야 합니다. 대화 상자, 크기를 조정할 수 있지만 필요 하지 않습니다.

크기 조정 가능한 대화 상자에 대 한 두 가지 권장 사항이 있습니다.

1. 최소 크기는 컨트롤에 대 한 최적화는 대화 상자에 대해 정의 된 클리핑 없이 설정 하 고 적절 한 지역화 증가 맞게 조정 합니다.

2. 사용자 규모 크기는 세션 간에 유지 합니다. 예를 들어, 사용자 150% 대화 상자를 확장 하는 경우 대화 상자의 이후 시작 150%에 표시 됩니다.

#### <a name="position"></a>위치
대화 상자를 처음 시작할 때 IDE 내에서 가운데 맞춤 나타나야 합니다. 후속 실행에서 가운데 맞춤 나타납니다 크기 조정이 불가능 대화의 마지막 위치에 유지 되도록 필요 하지 않습니다.

크기 조정 가능한 대화 상자에 대 한 후속 실행에서 크기를 유지 해야 합니다. 크기 조정 가능한 모달 대화 상자에 대 한 위치에 유지 될 필요가 없습니다. IDE 내에서 가운데에 표시 사용자의 디스플레이 구성이 변경 되 면 예측할 수 없거나 사용할 수 없는 위치에 표시 되는 대화의 가능성을 방지 합니다.

대화 상자는 대규모 워크플로의 일부로 자주 사용 될 수 사용자의 위치를 변경 될 수 있는 모덜리스 대화 상자에 대 한 후속 실행에서 유지 해야 합니다.

맨 위에 있는 대화 상자 오른쪽에 연계 해야 경우 대화 상자는 다른 대화 상자를 생성 해야, 확장 및 축소는 새로운 위치 탐색 한 사용자에 게 명확 하므로 부모입니다.

#### <a name="modality"></a>모달
모달 되 고 완료 하거나 계속 하기 전에 대화 상자를 취소 하는 데 필요한 사용자를 의미 합니다. 모달 대화 상자가 사용자 환경의 다른 부분과 상호 작용을 차단 하므로 작업 흐름 기능의 사용을으로 자제해 야 최대한 합니다. 모달 작업을 필요한 경우 Visual Studio에는 개수의 공유 대화 상자에 기능을 통합할 수 있습니다. 새 대화 상자, 작성 하는 경우 유사한 기능을 사용 하 여 기존 대화를의 상호 작용 패턴을 따릅니다.

사용자를 한 번에 두 작업을 수행 해야 하는 경우와 같은 **찾을** 하 고 **대체** 새 코드를 작성 하는 동안 대화 해야 모덜리스 사용자 서로 쉽게 전환할 수 있도록 합니다. 일반적으로 visual Studio는 이러한 종류의 편집기를 지 원하는 연결 된 작업에 대 한 도구 창을 사용합니다.

#### <a name="control-configuration"></a>컨트롤 구성
Visual Studio에서 같은 작업을 수행 하는 기존 컨트롤 구성으로 일관 되어야 합니다.

#### <a name="title-bars"></a>제목 표시줄

- 제목 표시줄에 텍스트를 실행 하는 명령 이름을 반영 해야 합니다.

- 대화 상자 제목 표시줄에 사용할 아이콘이 없습니다. 시스템에 필요한 경우 하나의 경우 Visual Studio 로고를 사용 합니다.

- 대화 상자를 사용 해야 최소화 또는 최대화 단추입니다.

- 제목 표시줄에 도움말 단추가 있는 더 이상 사용 되지 않습니다. 이러한 새 대화 상자를 추가 하지 마세요. 가 없으면, 태스크와 개념적으로 관련 된 도움말 항목을 시작 해야 있습니다.

  ![Visual Studio 대화 상자의 제목 표시줄에 대 한 지침 사양을](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704 03_TitleBarSpecs")<br />Visual Studio 대화 상자의 제목 표시줄에 대 한 지침 사양

#### <a name="control-buttons"></a>컨트롤 단추
일반적으로 **확인**를 **취소**, 및 **도움말** 대화 상자의 오른쪽 아래 모퉁이의 단추를 가로로 정렬 해야 합니다. 대화 상자 컨트롤 단추를 사용 하 여 visual 혼란을 초래 되는 대화 상자 아래쪽에 있는 여러 단추 있으면 대체 세로 스택을 허용 됩니다.

![Visual Studio 대화 상자의 단추 컨트롤에 대 한 허용 가능한 구성을](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704 04_ControlButtonConfig")<br />Visual Studio 대화 상자의 단추 컨트롤에 대 한 허용 구성

대화 상자에는 기본 컨트롤 단추를 포함 해야 합니다. 최상의 명령에서 기본값으로 사용을 확인 하려면 (우선 순위 순서 대로 나열 됨) 다음 옵션 중에서 선택 합니다.

- 기본적으로 안전 하 고 가장 안전한 명령을 선택 합니다. 즉, 데이터 손실을 방지 하 고 의도 하지 않은 시스템 액세스를 방지 하기 위해 가장 가능성이 높은 명령을 선택 합니다.

- 데이터가 손실 되 고 보안 요소가 없는 경우에 다음 편의에 따라 기본 명령을 선택 합니다. 기본적으로 가능성이 가장 높은 명령을 포함 하 여 대화 상자에서 자주 또는 반복적인 작업을 지 원하는 경우 사용자의 워크플로 향상 됩니다.

기본 명령에 대 한 영구적으로 삭제 작업을 선택 하지 마십시오. 이러한 명령을 있는 경우 안전 하 게 명령을 대신 기본적으로 선택 합니다.

#### <a name="access-keys"></a>선택키
에 대 한 액세스 키를 사용 하지 마세요 **확인**를 **취소**, 또는 **도움말** 단추입니다. 이러한 단추는 기본적으로 바로 가기 키에 매핑됩니다.

| 단추 이름 | 바로 가기 키 |
| --- | --- |
| 확인 | Enter 키 |
| 취소 | Esc |
| Help | F1 |

#### <a name="imagery"></a>이미지
대화 상자에서 이미지를 제한적으로 사용 합니다. 대화 상자에서 공간을 사용 하려면 단순히 큰 아이콘을 사용 하지 마세요. 경고 아이콘 또는 애니메이션 상태와 같은 사용자에 게 메시지를 전달 하는 중요 한 부분은 경우에 이미지를 사용 합니다.

### <a name="BKMK_PrioritizingAndLayering"></a> 우선 순위 지정 및 계층화

#### <a name="prioritizing-your-ui"></a>UI를 우선 순위 지정
Forefront를 특정 UI 요소를 가져오고 고급 동작 및 대화 상자에 옵션 (모호한 명령 포함)를 배치 해야 할 수도 있습니다. 표시 되도록 텍스트 레이블 지정 하 여 UI에서 기본적으로 대화 상자를 표시 하는 경우 및을 위한 공간을 확보 하 여 forefront에 자주 사용 되는 기능을 제공 합니다.

#### <a name="layering-your-ui"></a>UI를 계층화합니다.
대화 이지만 필요한 사용자에 게 제공 하려는 관련된 기능은 간단한 대화 상자에 표시할 수 있습니다 넘어 있는지를 확인 한 경우 UI 계층 해야 합니다. Visual Studio를 사용 하 여 가장 일반적인 계층 메서드는 탭 및 복도 또는 대시보드입니다. 경우에 따라 확장 및 축소할 수 있는 지역 적절할 수 있습니다. 적응 UI 일반적으로 Visual Studio에서 권장 되지 않습니다.

장점 및 단점 유사한 탭 컨트롤을 통해 UI를 계층화의 다른 메서드에 있습니다. 상황에 맞는 적절 한 레이어 기술을 선택 했는지 확인 하려면 아래 목록을 검토 합니다.

##### <a name="tabbing"></a>탭 이동

| 전환 메커니즘 | 장점 및 적절 한 사용 | 단점 및 부적절 한 사용 |
| --- | --- | --- |
| 탭 컨트롤 | 관련된 집합으로 대화 상자 페이지를 논리적으로 그룹화 합니다.<br /><br />5 개 미만의 (또는 대화 상자에서 한 행에 맞는 탭의 개수)에 대 한 유용한 대화 상자에서 관련된 컨트롤의 페이지<br /><br />탭 레이블을 짧아야: 콘텐츠를 쉽게 식별할 수 있는 하나 이상의 단어<br /><br />일반적인 시스템 대화 상자 스타일<br /><br />예제: **파일 탐색기 &gt; 항목 속성** | 짧은 설명 레이블이 하기가 어려울 수 있습니다.<br /><br />일반적으로 하나의 대화 상자에서 5 개 탭 지난 확장 되지 않습니다.<br /><br />부적절 한 행 (대체 계층화 하는 기법을 사용 하는 경우)에 대 한 많은 탭이 있는 경우<br /><br />확장할 수 없습니다 |
| 사이드바 탐색 | 탭 보다 더 많은 범주를 수용할 수 있는 간단한 전환 장치<br /><br />플랫 목록을 범주 (계층 구조)<br /><br />확장 가능<br /><br />예제: **사용자 지정... &gt; 명령 추가** | 가로 간격 세 대 보다 적은 그룹이 있는 경우 적절 하 게 사용 되지 않습니다<br /><br />작업은 드롭다운에 적합 한 더 잘 수 있습니다. |
| 트리 컨트롤 | 무제한 범주에 대 한 허용<br /><br />그룹화 및/또는 범주 계층 구조에 대 한 허용<br /><br />확장 가능<br /><br />예제: **도구 &gt; 옵션** | 많이 중첩 된 계층 구조는 과도 한 가로 스크롤이 발생할 수 있습니다.<br /><br />Visual Studio에는 트리 보기는 과도할 정도로 사용 되는 |
| 마법사 | 작업 완료를 사용 하 여 작업 기반, 순차적 단계를 통해 사용자를 안내 하는 여는 데 도움이 됩니다: 마법사는 상위 수준 작업 나타내고 개별 패널은 전반적인 작업을 수행 하는 데 필요한 하위 작업<br /><br />작업 때 사용자 할 여러 편집기를 사용 하 고 작업을 완료 하는 windows 도구와 Ui 경계를 교차 하는 경우에 유용<br /><br />작업 분기에서 요구 하는 경우에 유용<br /><br />작업 단계 간에 종속성을 포함 하는 경우에 유용<br /><br />결정 포크를 사용 하 여 유사한 작업을 여러 다른 비슷한 대화 상자가 횟수를 줄이는 한 대화 상자에서 표시 될 수 있습니다 하는 경우에 유용 | 순차 워크플로 필요 하지 않은 모든 작업에 대 한 부적절 한<br /><br />사용자가 많이 사용 되 고 너무 많은 단계를 사용 하 여 마법사에서 혼동 될 수 있습니다.<br /><br />기본적으로 마법사 화면 부동산 제한 |

##### <a name="hallways-or-dashboards"></a>복도 또는 대시보드
복도 및 대시보드는 대화 상자 또는 역할을 가리키는 다른 대화 상자 및 창 시작 하는 패널입니다. 잘 설계 된 "복도"만 가장 일반적인 옵션, 명령 및 일반적인 작업을 쉽게 수행할 수 있도록 설정에 즉시 표시 합니다. 여기서 실제 본사의 복도 입구 뒤 방 액세스를 제공 하는 같은 덜 일반적인 UI는 별도 "방" (종종 다른 대화 상자) 주 복도에서 액세스할 수 있는 관련 기능에 수집 됩니다.

단순히 대시보드는 덜 일반적인 기능을 별도 위치를 리팩터링 하지 않고 단일 컬렉션에서 사용할 수 있는 모든 기능을 제공 하는 UI 또는 합니다.

![Outlook에서 추가 UI를 노출 하는 데 복도 개념](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704 08_Hallway")<br />Outlook에서 추가 UI를 노출 하는 데 복도 개념

##### <a name="adaptive-ui"></a>적응 UI
사용량에 따라 표시 또는 숨기기 UI 또는 사용자의 자체 보고 환경은 또 다른 방법은 다른 부분을 숨기면 필요한 UI를 제공 합니다. UI를 표시할지 결정 알고리즘은 작업은 복잡할 수와 규칙은 일부 사례 집합에 대 한 잘못 된 경우 항상 Visual Studio에서 권장 되지는 않습니다.

## <a name="BKMK_Projects"></a> 프로젝트

### <a name="projects-in-the-solution-explorer"></a>솔루션 탐색기에서 프로젝트
대부분의 프로젝트와 참조 기반, 디렉터리 기반 또는 혼합 분류 됩니다. 솔루션 탐색기에서 세 가지 유형의 프로젝트를 모두 동시에 지원 됩니다. 프로젝트를 사용 하 여 작업에서 사용자 환경의 루트가이 창 내에서 이루어집니다. 다른 프로젝트 노드에 대 한 참조, 디렉터리 또는 혼합 형식 프로젝트 이지만, 이전 프로젝트 관련 사용자 패턴으로 수렴 하는 시작 지점으로 적용 해야 하는 일반적인 상호 작용 패턴 방법이 있습니다.

프로젝트 항상 수행 해야합니다.

- 프로젝트 콘텐츠를 구성 하는 프로젝트 폴더를 추가 하는 기능을 지원

- 프로젝트 지 속성에 대 한 일관 된 모델을 유지 관리

프로젝트에 대 한 일관 된 상호 작용 모델 유지 관리도 해야 합니다.

- 프로젝트 항목 제거

- 문서 저장

- 프로젝트 속성 편집

- 대체 보기에서 프로젝트를 편집합니다.

- 끌어서 놓기 작업

### <a name="drag-and-drop-interaction-model"></a>끌어서 놓기 상호 작용 모델
프로젝트에 자체 참조 기반으로 (할 저장소의 프로젝트 항목에 대 한 참조만 유지), 항목을 일반적으로 분류 디렉터리 기반 (실제로 유일한 프로젝트 항목을 지속할 수 저장 프로젝트의 계층 구조 내에서) 또는 혼합 (할 참조를 유지 합니다. 또는 실제 항목)입니다. IDE 내에서 동시에 모든 세 가지 유형의 프로젝트를 수용 합니다 **솔루션 탐색기**합니다.

끌어서 놓기 관점에서 다음 특성 내에서 프로젝트의 각 형식에 적용 해야 합니다 **솔루션 탐색기**:

- **프로젝트 기반 참조:** 요점은은 프로젝트 관련 저장소의 항목에 대 한 참조를 끌어가 것입니다. 이동 작업에 대 한 원본으로 작동 하는 참조 기반 프로젝트를 사용 하는 경우에 프로젝트에서 항목에 대 한 참조를 제거 해야 하 합니다. 항목 하드 드라이브에서 실제로 삭제 해야 합니다. 이동 (또는 복사) 작업에 대 한 대상으로 작동 하는 참조 기반 프로젝트를 사용 하는 경우 항목의 개인 복사본을 만들지 않고 원래 소스 항목에 대 한 참조를 추가 해야 합니다.

- **디렉터리 기반 프로젝트:** 끌어서 놓기의 관점에서 프로젝트 참조가 아니라 실제 항목 주위 끌어 됩니다. 이동 작업에 대 한 원본으로 작동 하는 디렉터리 기반 프로젝트를 사용 하는 경우 프로젝트에서 제거할 수 있을 뿐만 아니라 하드 드라이브에서 실제 항목 삭제를 끝나야 합니다. 디렉터리 기반 프로젝트를 이동 (또는 복사) 작업에 대 한 대상으로 역할을 하는 경우 대상 위치에서 소스 항목의 복사본을 확인 해야 하 합니다.

- **혼합 대상 프로젝트:** 끌어서 놓기의 관점에서이 유형의 프로젝트의 동작 됩니다 (저장소의 항목에 참조) 또는 항목과 끌고 있는 항목의 특성을 기반으로 합니다. 실제 항목 및 참조에 대 한 올바른 동작을 위에 설명 되어 있습니다.

프로젝트의 유형이 하나만 있다면 합니다 **솔루션 탐색기**, 다음 끌어서 놓기 작업을 간단 하 게 됩니다. 각 프로젝트 시스템 자체 끌어서 놓기 동작을 정의할 수 있으므로 특정 지침 (Windows 탐색기 끌어서 놓기 동작에 따라)을 예측 가능한 사용자 환경을 보장 하려면 따라야 합니다.

- 는 수정 되지 않은 끌기 작업을 **솔루션 탐색기** 이동 작업에서 발생 해야 (경우 Ctrl 또는 Shift 키를 모두는 누르고).

- 이동 작업을 shift 끌기 작업으로 인해도 해야 합니다.

- 복사 작업을 Ctrl 끌기 작업을 유발 합니다.

- 참조 기반 및 혼합 프로젝트 시스템은 소스 항목을 링크 (또는 참조)를 추가 하는 개념을 지원 합니다. 이러한 프로젝트는 끌어서 놓기 작업의 대상이 되 면 (때 **Ctrl + Shift** 를 누르고), 프로젝트에 추가 되는 항목에 대 한 참조에서 발생 해야

모든 끌어서 놓기 작업은 참조 기반, 디렉터리 기반 및 혼합 프로젝트의 조합을 통해 합리적인입니다. 특히, 소스 디렉터리 기반 프로젝트 이동 완료 되 면 원본 항목을 삭제 해야 하기 때문에 대상 참조 기반 프로젝트를 소스 디렉터리 기반 프로젝트 간에 이동 작업을 허용 하도록 노테이션 문제가 됩니다. 대상 프로젝트 기반 참조 한 다음 결국 삭제 된 항목에 대 한 참조를 사용 하 여 합니다.

잘못 된 대상 참조 기반 프로젝트 소스 항목의 독립 복사본을 사용 하지 않아야 하기 때문에 이러한 유형의 프로젝트 간에 복사 작업을 허용 하도록 노테이션 이기도 합니다. 마찬가지로, Ctrl + Shift를 대상 디렉터리 기반 프로젝트를 끌어 허용 하지 않아야 디렉터리 기반 프로젝트 참조를 유지할 수 없기 때문에 있습니다. 끌어서 놓기 작업이 지원 되지 않습니다 여기서 경우에서 IDE의 삭제를 허용 하지 않습니다 하 고 사용자 놓기 없음 커서 (포인터 테이블 아래에 표시)을 표시 해야 합니다.

끌어서 놓기 동작을 제대로 구현 하려면 끌기 소스 프로젝트가 대상 프로젝트에 해당 특성을 통신 해야 합니다. (예를 들어 인가요 참조 또는 디렉터리 기반) 이 정보는 원본에서 제공 되는 클립보드 형식으로 표시 됩니다. 끌어서 (또는 클립보드로 복사 작업)의 원본으로 프로젝트를 제공 해야 하거나 `CF_VSREFPROJECTITEMS` 또는 `CF_VSSTGPROJECTITEMS` 각각 인지 여부에 따라 프로젝트 기반 참조 디렉터리 기반 합니다. 이러한 형식의 둘 다 동일한 데이터 콘텐츠를 Windows 비슷합니다 `CF_HDROP` 파일 이름 대신 문자열 목록을 차이가 이중-형식`NULL` 목록을 종료 `Projref` 문자열 ( 반환된`IVsSolution::GetProjrefOfItem`또는 `::GetProjrefOfProject` 적절 하 게).

삭제 (또는 클립보드 붙여넣기 작업)의 대상으로 프로젝트는 둘 다 허용 `CF_VSREFPROJECTITEMS` 고 `CF_VSSTGPROJECTITEMS`되지만 정확한 처리 끌어서 놓기 작업의 대상 프로젝트와 원본 프로젝트의 성격에 따라 달라 집니다. 소스 프로젝트 제공 여부 하 여 해당 특성을 선언 `CF_VSREFPROJECTITEMS` 또는 `CF_VSSTGPROJECTITEMS`합니다. 드롭다운의 대상 자체 특성을 이해 하 고 있으므로 결과적으로 이동, 복사,으로 의사 결정에 충분 한 정보 또는 링크를 수행 해야 합니다. 또한 사용자는 Ctrl, shift 키 또는 둘 다 Ctrl 및 Shift 키를 눌러는 끌어서 놓기 작업을 수행 하도록 수정 합니다. 제대로 작업에 미리 수행할를 나타내기 위해 놓기 대상에 대 한 것이 반드시 해당 `DragEnter` 및 `DragOver` 메서드. 합니다 **솔루션 탐색기** 자동으로 소스 프로젝트와 대상 프로젝트에 동일한 프로젝트 되는지 여부를 알고 있습니다.

(예: 다른 devenv.exe의 하나의 인스턴스)에서 Visual Studio의 인스턴스를 통해 프로젝트 항목을 끌어 지원 하지 않습니다. 합니다 **솔루션 탐색기** 직접이 사용 하지 않습니다.

사용자 항상 항목을 선택 하 고 대상 위치로 끌어 다음 마우스 포인터의 나타나는 항목 삭제 전에 관찰 하 여 끌어서 놓기 작업의 효과 확인할 수 있어야 합니다.

| 마우스 포인터 | 명령 | 설명 |
| :---: | --- | --- |
| ![마우스 "끌어 놓기 없음" 아이콘](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706 01_MouseNoDrop") | 끌어 놓기 없음 | 지정된 된 위치에 항목을 삭제할 수 없습니다. |
| ![Mouse "copy" icon](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 복사 | 항목 대상 위치에 복사 됩니다. |
| ![마우스 "이동" 아이콘](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706 03_MouseMove") | 이동 | 항목 대상 위치로 이동 됩니다. |
| ![마우스 "참조 추가" 아이콘이](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706 04_MouseAddRef") | 참조 추가 | 선택한 항목에 대 한 참조를 대상 위치에 추가 됩니다. |

#### <a name="reference-based-projects"></a>프로젝트 기반 참조
 다음 표에서 참조 기반 대상 프로젝트에 대 한 누를 원본 항목 및 한정자 키 특성에 따라 (잘라내기/복사/붙여넣기) 및 끌어서 놓기 작업을 수행 해야 하는 요약 되어 있습니다.

| 한정자 | 범주 | 소스 항목: 참조/링크 | 소스 항목: 실제 항목 또는 파일 시스템 (`CF_HDROP`) |
| --- | --- | --- | --- |
| 어떠한 한정자 | 작업 | 이동 | 링크 |
| 어떠한 한정자 | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 원래 항목에 대 한 참조를 추가합니다. |
| 어떠한 한정자 | Source | 원래 항목에 대 한 참조를 삭제 | 원래 항목을 그대로 유지 |
| 어떠한 한정자 | 결과 | `DROPEFFECT_MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_LINK` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| Shift+Drag | 작업 | 이동 | 끌어 놓기 없음 |
| Shift+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 끌어 놓기 없음 |
| Shift+Drag | Source | 원래 항목에 대 한 참조를 삭제 | 끌어 놓기 없음 |
| Shift+Drag | 결과 | `DROPEFFECT_MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | 끌어 놓기 없음 |
| Ctrl+Drag | 작업 | 복사 | 끌어 놓기 없음 |
| Ctrl+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 끌어 놓기 없음 |
| Ctrl+Drag | Source | 원래 항목에 대 한 참조를 유지합니다. | 끌어 놓기 없음 |
| Ctrl+Drag | 결과 | `DROPEFFECT_COPY` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | 끌어 놓기 없음 |
| Ctrl+Shift+Drag | 작업 | 링크 | 링크 |
| Ctrl+Shift+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 원래 항목에 대 한 참조를 추가합니다. |
| Ctrl+Shift+Drag | Source | 원래 항목에 대 한 참조를 유지합니다. | 원래 항목을 그대로 유지 |
| Ctrl+Shift+Drag | 결과 | `DROPEFFECT_LINK` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_LINK` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| Ctrl+Shift+Drag | 참고 | Windows 탐색기에서 바로 가기에 대 한 끌어서 놓기 동작와 동일 합니다. ||
| 잘라내기/붙여넣기 | 작업 | 이동 | 링크 |
| 잘라내기/붙여넣기 | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 원래 항목에 대 한 참조를 추가합니다. |
| 잘라내기/붙여넣기 | Source | 원래 항목에 대 한 참조를 유지합니다.|원래 항목을 그대로 유지 |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 유지 됩니다. | 항목은 저장소의 원래 위치에 유지 됩니다. |
| 복사/붙여넣기 | 작업 | 복사 | 링크 |
| 복사/붙여넣기 | Source | 원래 항목에 대 한 참조를 추가합니다. | 원래 항목에 대 한 참조를 추가합니다. |
| 복사/붙여넣기 | 결과 | 원래 항목에 대 한 참조를 유지합니다. | 원래 항목을 그대로 유지 |
| 복사/붙여넣기 | 작업 | 항목은 저장소의 원래 위치에 유지 됩니다. | 항목은 저장소의 원래 위치에 유지 됩니다. |

#### <a name="directory-based-projects"></a>디렉터리 기반 프로젝트
다음 표에서 대상 디렉터리 기반 프로젝트에 대 한 누를 원본 항목 및 한정자 키 특성에 따라 (잘라내기/복사/붙여넣기) 및 끌어서 놓기 작업을 수행 해야 하는 요약 되어 있습니다.

| 한정자 | 범주 | 소스 항목: 참조/링크 | 소스 항목: 실제 항목 또는 파일 시스템 (`CF_HDROP`) |
|-----------------|----------| - | - |
| 어떠한 한정자 | 작업 | 이동 | 이동 |
| 어떠한 한정자 | 대상 | 대상 위치에 복사 항목 | 대상 위치에 복사 항목 |
| 어떠한 한정자 | Source | 원래 항목에 대 한 참조를 삭제 | 원래 항목에 대 한 참조를 삭제 |
| Shift+Drag | 작업 | 이동 | 이동 |
| Shift+Drag | 대상 | 대상 위치에 복사 항목 | 대상 위치에 복사 항목 |
| Shift+Drag | Source | 원래 항목에 대 한 참조를 삭제 | 원래 위치에서 항목을 삭제합니다. |
| Shift+Drag | 결과 | `DROPEFFECT_MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| Ctrl+Drag | 작업 | 복사 | 복사 |
| Ctrl+Drag | 대상 | 대상 위치에 복사 항목 | 대상 위치에 복사 항목 |
| Ctrl+Drag | Source | 원래 항목에 대 한 참조를 유지합니다. | 원래 항목에 대 한 참조를 유지합니다. |
| Ctrl+Drag | 결과 | `DROPEFFECT_COPY` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_COPY` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| Ctrl+Shift+Drag | | 끌어 놓기 없음 | 끌어 놓기 없음 |
| 잘라내기/붙여넣기 | 작업 | 이동 | 이동 |
| 잘라내기/붙여넣기 | 대상 | 대상 위치에 복사 항목 | 대상 위치에 복사 항목 |
| 잘라내기/붙여넣기 | Source | 원래 항목에 대 한 참조를 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 유지 됩니다. | 저장소의 원래 위치에서 항목을 삭제 |
| 복사/붙여넣기 | 작업 | 복사 | 복사 |
| 복사/붙여넣기 | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 대상 위치에 복사 항목 |
| 복사/붙여넣기 | Source | 원래 항목을 그대로 유지 | 원래 항목을 그대로 유지 |
| 복사/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 유지 됩니다. | 항목은 원래 위치 기능 저장소에 유지 됩니다. |

#### <a name="mixed-target-projects"></a>혼합 대상 프로젝트
다음 표에서 누른 혼합 대상 프로젝트에 대 한 원본 항목 및 한정자 키 특성에 따라 (잘라내기/복사/붙여넣기) 및 끌어서 놓기 작업을 수행 해야 하는 요약 되어 있습니다.

| 한정자 | 범주 | 소스 항목: 참조/링크 | 소스 항목: 실제 항목 또는 파일 시스템 (`CF_HDROP`) |
| --- | --- | --- | --- |
| 어떠한 한정자 | 작업 | 이동 | 이동 |
| 어떠한 한정자 | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 대상 위치에 복사 항목 |
| 어떠한 한정자 | Source | 원래 항목에 대 한 참조를 삭제 | 원래 항목에 대 한 참조를 삭제 |
| 어떠한 한정자 | 결과 | `DROPEFFECT_ MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_ MOVE` 작업으로 반환 됩니다 `::Drop` 저장소의 원래 위치에서 항목을 삭제 하 고 |
| Shift+Drag | 작업 | 이동 | 이동 |
| Shift+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 대상 위치에 복사 항목 |
| Shift+Drag | Source | 원래 항목에 대 한 참조를 삭제 | 원래 위치에서 항목을 삭제합니다. |
| Shift+Drag | 결과 | `DROPEFFECT_ MOVE` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_ MOVE` 작업으로 반환 됩니다 `::Drop` 저장소의 원래 위치에서 항목을 삭제 하 고 |
| Ctrl+Drag | 작업 | 복사 | 복사 |
| Ctrl+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 대상 위치에 복사 항목 |
| Ctrl+Drag | Source | 원래 항목에 대 한 참조를 유지합니다. | 원래 항목을 그대로 유지 |
| Ctrl+Drag | 결과 | `DROPEFFECT_ COPY` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_ COPY` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| Ctrl+Shift+Drag | 작업 | 링크 | 링크 |
| Ctrl+Shift+Drag | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 원래 원본 항목에 대 한 참조를 추가합니다. |
| Ctrl+Shift+Drag | Source | 원래 항목에 대 한 참조를 유지합니다. | 원래 항목을 그대로 유지 |
| Ctrl+Shift+Drag | 결과 | `DROPEFFECT_ LINK` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. | `DROPEFFECT_ LINK` 작업으로 반환 됩니다 `::Drop` 항목 저장소에 원래 위치에 유지 됩니다. |
| 잘라내기/붙여넣기 | 작업 | 이동 | 이동 |
| 잘라내기/붙여넣기 | 대상 | 대상 위치에 복사 항목 | 대상 위치에 복사 항목 |
| 잘라내기/붙여넣기 | Source | 원래 항목에 대 한 참조를 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 유지 됩니다. | 저장소의 원래 위치에서 항목을 삭제 |
| 복사/붙여넣기 | 작업 | 복사 | 복사 |
| 복사/붙여넣기 | 대상 | 원래 항목에 대 한 참조를 추가합니다. | 대상 위치에 복사 항목 |
| 복사/붙여넣기 | Source | 원래 항목을 그대로 유지 | 원래 항목을 그대로 유지 |
| 복사/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 유지 됩니다. | 항목은 저장소의 원래 위치에 유지 됩니다. |

이러한 세부 정보는 고려해 야 끌기 구현 하는 경우는 **솔루션 탐색기**:

- 여러 선택 영역 시나리오에 대 한 디자인 합니다.

- 대상 프로젝트에서 파일 이름 (전체 경로)는 고유 해야 하거나 드롭다운 허용 하지 않아야 합니다.

- 폴더 이름은 고유 해야 합니다. 삭제 되는 수준 (대/소문자).

- 열림 또는 닫힘 (위 시나리오에서 언급 되지) 끌어서 시점에는 파일 간의 동작 차이가 있습니다.

- 최상위 파일 폴더의 파일와는 약간 다르게 작동합니다.

알아야 할 다른 문제 열려 디자이너 또는 편집기에 있는 항목의 이동 작업을 처리할 수 있는 방법이 있습니다. 예상 되는 동작 (모든 프로젝트 형식에 적용) 같이 수행 됩니다.

1. 편집기/디자이너 열기 저장 되지 않은 모든 변경 내용이 없으면 편집기/디자이너 창은 자동으로 닫을 수 해야 합니다.

2. 편집기/디자이너 열기 변경 내용이 저장 되지 않은, 끌기 원본이 발생 한 후 다음과 유사한 프롬프트가 창을 닫기 전에 커밋되지 않은 변경 내용을 열려 있는 문서에 저장 하려면 사용자에 게 요청을 삭제 대기 해야 :

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

이렇게 하면 사용자를 대상 복사본을 수행 하기 전에 진행 중인 작업을 저장할 수 있습니다. 새 메서드 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 이 처리를 사용 하도록 설정 하려면 추가 되었습니다.

저장소에 있는 것과 대상 항목의 상태를 다음 복사 됩니다 (사용자 선택 하는 경우 편집기에서 저장 되지 않은 변경 내용을 제외한 **No**). 대상에서 해당 복사를 완료 된 후 (에서 `IVsHierarchyDropDataSource::Drop`), 원본 이동 작업의 삭제를 완료 하는 기회가 제공 됩니다 (에서 `IVsHierarchyDropDataSource::OnDropNotify`).

저장 되지 않은 변경 내용이 포함 된 모든 편집기를 열어 두어야 합니다. 해당 문서를 저장 하지 않은 변경에 대 한 즉 복사 부분 이동 작업을 수행할 수는 있지만 삭제 부분 중단 됩니다. 사용자가 여러 선택 영역 시나리오에서 **No**저장 되지 않은 변경을 사용 하 여 해당 문서 종료 되거나 제거 되지 않아야 되지만 변경 내용을 저장 하지 않고도 닫고 해야 제거 합니다.