---
title: 비주얼 스튜디오용 애플리케이션 패턴 | 마이크로 소프트 문서
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 036c95951fe3dc9e65a0f3338f75ae9867d721c3
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80698591"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio의 애플리케이션 패턴
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a>창 상호 작용

### <a name="overview"></a>개요
Visual Studio에서 사용되는 두 가지 주요 창 유형은 문서 편집기와 도구 창입니다. 드물지만 가능한 큰 모덜리스 대화 상자입니다. 이러한 것들은 모두 쉘에서 모덜리스이지만 패턴은 근본적으로 다릅니다. 이 섹션에서는 문서 창, 도구 창 및 모데리스 대화 상자간의 차이점을 다룹니다. 모달 대화 상자 패턴은 [대화 상자에서 다룹니다.](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)

### <a name="comparing-window-usage-patterns"></a>창 사용 패턴 비교
**문서 창은** 거의 항상 문서 내에 잘 표시됩니다. 이렇게 하면 문서 편집기에서 추가 도구 창을 정렬할 수 있는 "중앙 단계"가 됩니다.

**도구 창은** IDE 가장자리에 대해 축소된 별도의 작은 창으로 가장 자주 표시됩니다. 표시, 숨김 또는 자동 숨김이 가능합니다. 그러나 창에서 **Window/Docking** 속성을 선택 취소하여 문서 내에 도구 창이 잘 표시되는 경우가 있습니다. 이로 인해 더 많은 부동산이 발생하지만 일반적인 디자인 결정도 있습니다: Visual Studio에 통합하려고 할 때 피처에 도구 창또는 문서 창을 표시할지 여부를 결정해야 합니다.

**비주얼 스튜디오에서는 모드없는 대화 상자가** 권장되지 않습니다. 대부분의 모덜리스 대화 상자는 정의에 따라 부동 도구 창이며 이러한 방식으로 구현되어야 합니다. 모덜리스 대화 상자는 쉘의 측면에 도킹된 일반 도구 창의 크기가 너무 제한적인 경우에 허용됩니다. 또한 사용자가 대화 상자를 보조 모니터로 이동할 가능성이 있는 경우에도 허용됩니다.

필요한 컨테이너 유형에 대해 신중하게 생각하십시오. UI 디자인에 대한 일반적인 사용 패턴 고려 사항은 다음 표에 있습니다.

||문서 창|공구 창|모드 없는 대화 상자|
|-|---------------------|-----------------|---------------------|
| **위치** | 항상 문서 내에 잘 배치되고 IDE의 가장자리 주위에 도킹되지 않습니다. 주 쉘과 별도로 부동되도록 "당겨"될 수 있습니다. | 일반적으로 IDE의 가장자리 주위에 탭 도킹, 하지만 부동, 자동 숨김 (고정 되지 않은) 또는 잘 문서 내에서 도킹 하도록 사용자 지정할 수 있습니다.|IDE와 분리된 대형 부동 창입니다. |
| **커밋 모델** | *지연된 커밋*<br /><br /> 문서에 데이터를 저장하려면 사용자가 **파일 &gt; 저장,** **로 저장**또는 모두 **저장** 명령을 수행해야 합니다. 문서 창에는 저장 명령 중 하나에 커밋된 다음 "더럽혀진" 데이터 개념이 있습니다. 문서 창을 닫을 때 모든 내용이 디스크에 저장되거나 손실됩니다. | *즉각적인 커밋*<br /><br /> 저장 모델이 없습니다. 파일 편집에 도움이 되는 검사기 도구 창의 경우 파일은 활성 편집기 또는 디자이너에서 열려 있어야 하며 편집기 또는 디자이너는 저장을 소유합니다. | *지연되거나 즉각적인 커밋*<br /><br /> 대부분의 경우 대규모 모덜리스 대화 상자에서는 변경 내용을 커밋하는 작업이 필요하며 대화 상자 세션 내에서 변경한 내용을 롤백하는 "취소" 작업을 허용합니다.  이렇게 하면 모덜리스 대화 상자가 항상 즉각적인 커밋 모델이 있는 도구 창의 도구 창과 구별됩니다. |
| **표시 유형** | *열기/만들기(파일) 및 닫기*<br /><br /> 문서 창을 여는 작업은 기존 문서를 열거나 템플릿을 사용하여 새 문서를 만드는 작업을 수행합니다. "특정 편집기 \<열기>" 명령이 없습니다. | *숨기기 및 표시*<br /><br /> 단일 인스턴스 도구 창을 숨기거나 표시할 수 있습니다. 도구 창 내의 내용및 상태는 뷰에서든 숨김이든 유지됩니다. 다중 인스턴스 도구 창은 닫을 뿐만 아니라 숨길 수 있습니다. 다중 인스턴스 도구 창이 닫히면 도구 창 내의 콘텐츠 및 상태가 삭제됩니다. | *명령에서 시작*<br /><br /> 대화 상자는 작업 기반 명령에서 시작됩니다. |
| **인스턴스** | *다중 인스턴스*<br /><br /> 여러 편집기를 동시에 열고 다른 파일을 편집할 수 있으며 일부 편집자는 동일한 파일을 둘 이상의 편집기에서 열 수 **있습니다(새 &gt; 창** 창 사용 명령 사용).<br /><br /> 단일 편집기는 하나 또는 여러 개의 파일을 동시에 편집할 수 있습니다(프로젝트 디자이너). | *단일 또는 다중 인스턴스*<br /><br /> 콘텐츠는 컨텍스트를 반영하도록 변경되거나(속성 브라우저에서와 같이) 포커스/컨텍스트를 다른 창(작업 목록, 솔루션 탐색기)으로 푸시합니다.<br /><br /> 단일 인스턴스 및 다중 인스턴스 도구 창은 강제할 이유가 없는 한 활성 문서 창과 연결되어야 합니다. | *단일 인스턴스* |
| **예** | **텍스트 편집기,** 코드 편집기 와 같은<br /><br /> 양식 디자이너 또는 모델링 표면과 같은 **설계 서피스**<br /><br /> 매니페스트 디자이너와 같은 **대화 상자와 유사한 레이아웃 제어** | **솔루션 탐색기는** 솔루션 내에 포함된 솔루션 및 프로젝트를 제공합니다.<br /><br /> **서버 탐색기는** 사용자가 창에서 열도록 선택한 서버 및 데이터 연결에 대한 계층적 보기를 제공합니다. 쿼리와 같은 데이터베이스 계층 구조에서 개체를 열면 문서 창이 열리고 사용자가 쿼리를 편집할 수 있습니다.<br /><br /> **속성 브라우저는** 문서 창 또는 다른 도구 창에서 선택한 개체에 대한 속성을 표시합니다. 속성은 계층적 그리드 보기 또는 복잡한 대화 와 같은 컨트롤에서 표시되며 사용자가 해당 속성에 대한 값을 설정할 수 있습니다. | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a>공구 창

### <a name="overview"></a>개요
도구 창은 문서 창에서 발생하는 사용자의 작업을 지원합니다. Visual Studio에서 제공하고 조작할 수 있는 기본 루트 개체를 나타내는 계층구조를 표시하는 데 사용할 수 있습니다.

IDE의 새 도구 창을 고려할 때 작성자는 다음을 수행해야 합니다.

- 작업에 적합한 기존 도구 창을 사용하고 유사한 기능을 가진 새 도구를 만들지 마십시오. 새 도구 창은 유사한 창에 통합할 수 없는 상당히 다른 "도구" 또는 기능을 제공하거나 기존 창을 피벗 허브로 전환해야 합니다.

- 필요한 경우 도구 창 상단에 표준 명령 모음을 사용합니다.

- 컨트롤 프레젠테이션 및 키보드 탐색을 위해 다른 도구 창에 이미 있는 패턴과 일치해야 합니다.

- 다른 도구 창에서 컨트롤 프레젠테이션과 일치합니다.

- 가능하면 문서별 도구 창을 자동으로 표시하여 상위 문서가 활성화된 경우에만 표시되도록 합니다.

- 키보드(지원 화살표 키)에서 창 콘텐츠를 탐색할 수 있는지 확인합니다.

#### <a name="tool-window-states"></a>도구 창 상태
Visual Studio 도구 창에는 상태가 다르며, 그 중 일부는 자동 숨기기 기능과 같이 사용자가 활성화됩니다. 자동 표시와 같은 다른 상태는 도구 창이 올바른 컨텍스트에 표시되고 필요하지 않을 때 숨길 수 있도록 합니다. 총 5개의 도구 창 상태가 있습니다.

- **도킹/고정된** 공구 창은 문서 영역의 네 면 중 한 쪽에 부착할 수 있습니다. 푸시핀 아이콘이 도구 창 제목 표시줄에 나타납니다. 도구 창은 쉘 및 기타 도구 창의 가장자리를 따라 가로 또는 세로로 도킹할 수 있으며 탭 연결도 가능합니다.

- **자동 숨겨진** 도구 창은 고정해제되어 있습니다. 창이 보이지 않는 곳에서 미끄러져 문서 영역 가장자리에 탭(도구 창 이름과 아이콘)을 남길 수 있습니다. 사용자가 탭 위로 마우스를 가져가면 도구 창이 밖으로 미끄러지입니다.

- **편집기와** 같은 다른 UI 조각이 시작되거나 포커스가 향상되면 자동 표시 도구 창이 자동으로 나타납니다.

- **부동** 도구 창은 IDE 외부로 마우스를 가져갑니다. 이 기능은 다중 모니터 구성에 유용합니다.

- **탭된 문서** 도구 창은 문서 내에 잘 도킹할 수 있습니다. 이 기능은 개체 브라우저와 같은 대형 도구 창에 유용하며 프레임 가장자리에 도킹하는 것보다 더 많은 부동산이 필요합니다.

![Visual Studio의 도구 창 상태](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "01_ToolWindowStates 0702-01_ToolWindowStates")<br />Visual Studio의 도구 창 상태

#### <a name="single-instance-and-multi-instance"></a>단일 인스턴스 및 다중 인스턴스
도구 창은 단일 인스턴스 또는 다중 인스턴스입니다. 일부 단일 인스턴스 도구 창은 활성 문서 창과 연결될 수 있지만 다중 인스턴스 도구 창은 연결되지 않을 수 있습니다. 다중 인스턴스 도구 창은 **창의 &gt; ** 새 인스턴스를 만들어 창 새 창 명령에 응답합니다. 다음 이미지는 창 인스턴스가 활성 상태일 때 새 창 명령을 사용하도록 설정하는 도구 창을 보여 줍니다.

![창 인스턴스가 활성화되어 있을 때 '새 창' 명령을 사용하도록 설정하는 도구 창](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "02_ToolWindowEnablingCommand 0702-02_ToolWindowEnablingCommand")<br />창 인스턴스가 활성화되어 있을 때 '새 창' 명령을 사용하도록 설정하는 도구 창

단일 인스턴스 도구 창을 숨기거나 표시할 수 있으며 다중 인스턴스 도구 창은 닫을 수 있을 뿐만 아니라 숨길 수도 있습니다. 모든 도구 창을 도킹, 탭 연결, 부동 또는 문서 창과 유사하게 MDI(다중 문서 인터페이스) 자식 창으로 설정할 수 있습니다. 모든 도구 창은 창 메뉴의 적절한 창 관리 명령에 응답해야 합니다.

![시각적 스튜디오 창 메뉴의 창 관리 명령](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />시각적 스튜디오 창 메뉴의 창 관리 명령

#### <a name="document-specific-tool-windows"></a>문서별 도구 창
일부 도구 창은 지정된 문서 유형에 따라 변경되도록 설계되었습니다. 이러한 창은 IDE의 활성 문서 창에 적용할 수 있는 기능을 반영하도록 지속적으로 업데이트됩니다.

선택한 편집기를 반영하도록 내용이 변경되는 도구 창의 예로는 도구 상자및 문서 개요가 있습니다. 이러한 창에는 편집기의 창에 컨텍스트를 제공하지 않는 포커스가 있는 경우 워터마크가 표시됩니다.

#### <a name="navigable-list-tool-windows"></a>탐색 가능한 목록 도구 창
일부 도구 창에는 사용자가 상호 작용할 수 있는 탐색 가능한 항목 목록이 표시됩니다. 이 유형의 창에는 창이 비활성 상태인 경우에도 목록의 현재 항목에 대한 피드백이 항상 있어야 합니다. 목록은 창에서 현재 선택한 항목을 변경하여 **GoToNextLocation** 및 **GoToPrevLocation** 명령에 응답해야 합니다.

탐색 가능한 목록 도구 창의 예로는 솔루션 탐색기 및 결과 찾기 창이 있습니다.

### <a name="tool-window-types"></a>공구 창 유형

#### <a name="common-tool-windows-and-their-functions"></a>일반적인 공구 창 및 기능

**계층적 도구 창**

| 공구 창 | 함수 |
| --- | --- |
| 솔루션 탐색기 | 프로젝트, 기타 파일 및 솔루션 항목에 포함된 문서 목록을 표시하는 계층적 트리입니다. 프로젝트 내의 항목 표시는 프로젝트 유형을 소유하는 패키지(예: 참조 기반, 디렉터리 기반 또는 혼합 모드 유형)에 의해 정의됩니다. |
| 클래스 뷰 | 파일 자체와 는 별개로 클래스의 계층적 트리와 문서 작업 집합의 다양한 요소입니다. |
| 서버 탐색기 | 솔루션의 모든 서버 및 데이터 연결을 표시하는 계층적 트리입니다. |
| 문서 개요 | 활성 문서의 계층 구조입니다. |

**그리드 도구 창**

| 공구 창 | 함수 |
| --- | --- |
| 속성 | 선택한 객체에 대한 속성 목록과 해당 속성을 편집할 값 선택기를 표시하는 그리드입니다. |
| 작업 목록 | 사용자가 작업 및 주석을 생성/편집/삭제할 수 있는 그리드입니다. |

**콘텐츠 도구 창**

| 공구 창 | 함수 |
| --- | --- |
| 도움말 | 사용자가 "어떻게 해야 합니까?" 에서 도움을 받는 다양한 방법에 액세스할 수 있는 창입니다. MSDN 포럼에 비디오를 제공합니다. |
| 동적 도움말 | 현재 선택 영역에 적용할 수 있는 데 도움이 되는 항목에 대한 링크를 표시하는 도구 창입니다. |
| 개체 브라우저 | 왼쪽 창에 계층적 개체 구성 요소 목록과 오른쪽 열에 개체의 속성 및 메서드가 있는 2열 프레임 집합입니다. |

**대화 상자 도구 창**

| 공구 창 | 함수 |
| --- | --- |
| 찾기 | 사용자가 솔루션 내의 다양한 파일을 찾거나 찾고 바꿀 수 있는 대화 상자입니다. |
| 고급 찾기 | 사용자가 솔루션 내의 다양한 파일을 찾거나 찾고 바꿀 수 있는 대화 상자입니다. |

**기타 공구 창**

::: moniker range="vs-2017"

| 공구 창 | 함수 |
| --- | --- |
| 도구 상자 | 설계 표면에 삭제되는 요소를 저장하는 데 사용되는 도구 창은 모든 디자이너에게 일관된 드래그 소스를 제공합니다. |
| 시작 페이지 | 개발자 뉴스, Visual Studio 도움말 및 최근 프로젝트의 피드에 액세스할 수 있는 Visual Studio에 대한 사용자의 포털입니다. 또한 사용자는 "Common7\IDE\StartPages 비주얼 스튜디오 프로그램 파일 디렉토리에서 "Common7\IDE\StartPages\" 비주얼 스튜디오 프로그램 디렉토리에서 시작 페이지"를 복사한 다음 XAML을 손으로 편집하거나 Visual Studio 또는 다른 코드 편집기에서 열어 사용자 지정 시작 페이지를 만들 수 있습니다. |

::: moniker-end

::: moniker range=">=vs-2019"

| 공구 창 | 함수 |
| --- | --- |
| 도구 상자 | 설계 표면에 삭제되는 요소를 저장하는 데 사용되는 도구 창은 모든 디자이너에게 일관된 드래그 소스를 제공합니다. |

::: moniker-end

**디버거 도구 창**

| 공구 창 | 함수 |
| --- | --- |
| 자동 ||
| 즉시 ||
| 출력 | 출력 창은 선언할 텍스트 이벤트 또는 상태가 있을 때마다 사용할 수 있습니다. |
| 메모리 ||
| 중단점 ||
| 실행 중 ||
| 문서 ||
| 호출 스택 ||
| 로컬 ||
| 시계 ||
| 디스어셈블리 ||
| 레지스터 ||
| 스레드 ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>문서 편집기 규칙

### <a name="document-interactions"></a>문서 상호 작용
"문서 잘"은 IDE 내에서 가장 큰 공간이며 사용자가 일반적으로 보조 도구 창의 지원을 받아 작업을 완료하기 위해 주의를 집중한 곳입니다. 문서 편집기는 사용자가 Visual Studio내에서 열고 저장하는 기본 작업 단위를 나타냅니다. 솔루션 탐색기 또는 기타 활성 계층 구조 창에 연결된 강력한 선택 감각을 유지합니다. 사용자는 이러한 계층 화 창 중 하나를 가리키고 문서가 포함된 위치와 솔루션, 프로젝트 또는 Visual Studio 패키지에서 제공하는 다른 루트 개체와의 관계를 알 수 있어야 합니다.

문서 편집에는 일관된 사용자 환경이 필요합니다. 사용자가 창 관리 및 명령 찾기 대신 현재 작업에 집중할 수 있도록 하려면 해당 문서 형식을 편집하기 위한 사용자 작업에 가장 적합한 문서 보기 전략을 선택합니다.

#### <a name="common-interactions-for-the-document-well"></a>문서에 대한 일반적인 상호 작용

- 일반적인 **새 파일** 및 **파일 열기** 환경에서 일관된 상호 작용 모델을 유지 관리합니다.

- 문서 창이 열릴 때 관련 창 및 메뉴에서 관련 기능을 업데이트합니다.

- 메뉴 명령은 **편집,** **형식**및 **보기** 메뉴와 같은 공통 메뉴에 적절하게 통합됩니다. 상당한 양의 특수 명령을 사용할 수 있는 경우 새 메뉴를 만들 수 있습니다. 이 새 메뉴는 문서에 포커스가 있는 경우에만 표시되어야 합니다.

- 포함된 도구 모음은 편집기 맨 위에 배치될 수 있습니다. 이는 편집기 외부에 나타나는 별도의 도구 모음을 갖는 것이 좋습니다.

- 항상 솔루션 탐색기 또는 이와 유사한 활성 계층 구조 창에서 선택 항목을 유지 관리합니다.

- 솔루션 탐색기에서 문서를 두 번 클릭하면 **Open**과 동일한 작업을 수행해야 합니다.

- 문서 형식에서 둘 이상의 편집기를 사용할 수 있는 경우 사용자는 파일을 마우스 오른쪽 단추로 클릭하고 바로 가기 메뉴에서 **열기를** 선택하여 대화 상자 **열기를** 사용하여 지정된 문서 유형의 기본 작업을 재정의하거나 재설정할 수 있습니다.

- 문서에서 마법사를 작성하지 마십시오.

### <a name="user-expectations-for-specific-document-types"></a>특정 문서 유형에 대한 사용자 기대치
문서 편집기에는 여러 가지 기본 유형이 있으며 각 문서에는 동일한 유형의 다른 유형과 일치하는 상호 작용 집합이 있습니다.

- **텍스트 기반 편집기:** 코드 편집기, 로그 파일

- **설계 표면:** WPF 양식 디자이너, 윈도우 양식

- **대화 스타일 편집기:** 매니페스트 디자이너, 프로젝트 속성

- **모델 디자이너:** 워크플로 우디자이너, 코드맵, 아키텍처 다이어그램, 진행

문서를 잘 사용하는 몇 가지 비편집형식도 있습니다. 문서 자체는 편집하지 않지만 문서 창에 대한 표준 상호 작용을 따라야 합니다.

- **보고서:** IntelliTrace 보고서, 하이퍼-V 보고서, 프로파일러 보고서

- **대시보드:** 진단 허브

#### <a name="text-based-editors"></a>텍스트 기반 편집기

- 문서는 미리 보기 탭 모델에 참여하므로 문서를 열지 않고도 미리 볼 수 있습니다.

- 문서의 구조는 문서 개요와 같은 컴패니언 도구 창 내에서 표시될 수 있습니다.

- IntelliSense(해당하는 경우)는 다른 코드 편집기와 일관되게 행동합니다.

- 팝업 또는 보조 UI는 CodeLens와 같은 기존 유사한 UI에 대해 유사한 스타일과 패턴을 따릅니다.

- 문서 상태와 관련된 메시지는 문서 상단의 정보 표시줄 컨트롤또는 상태 표시줄에 표시됩니다.

- 사용자는 **도구 > 옵션** 페이지(공유 글꼴 및 색상 페이지 또는 편집기와 관련된 페이지)를 사용하여 글꼴 및 색상의 모양을 사용자 지정할 수 있어야 합니다.

#### <a name="design-surfaces"></a>설계 표면

- 빈 디자이너는 시작 하는 방법을 나타내는 표면에 워터마크가 있어야 합니다.

- 뷰 스위칭 메커니즘은 코드 편집기를 열기 위해 두 번 클릭하거나 문서 창 내의 탭과 같은 기존 패턴을 따라 두 창과 상호 작용을 허용합니다.

- 매우 구체적인 도구 창이 필요하지 않는 한 설계 표면에 요소를 추가하려면 도구 상자를 통해 수행해야 합니다.

- 표면의 항목은 일관된 선택 모델을 따릅니다.

- 포함된 도구 모음에는 **문서별**명령만 포함하며 저장 과 같은 일반적인 명령은 포함되어 있지 않습니다.

#### <a name="dialog-style-editors"></a>대화 스타일 편집기

- 컨트롤 레이아웃은 일반 대화 상자 레이아웃 규칙을 따라야 합니다.

- 편집기 내의 탭은 문서 탭의 모양과 일치하지 않아야 하며 허용된 두 개의 내부 탭 스타일 중 하나와 일치해야 합니다.

- 사용자는 키보드만 사용하여 컨트롤과 상호 작용할 수 있어야 합니다. 편집기 활성화 및 컨트롤을 통해 탭 또는 표준 니모닉을 사용하여 중 하나.

- 디자이너는 공통 저장 모델을 사용해야 합니다. 다른 단추는 적절할 수 있지만 전체 저장 또는 커밋 단추를 표면에 배치해서는 안 됩니다.

#### <a name="model-designers"></a>모델 디자이너

- 빈 디자이너는 시작 하는 방법을 나타내는 표면에 워터마크가 있어야 합니다.

- 설계 표면에 요소를 추가하는 것은 도구 상자를 통해 수행해야 합니다.

- 표면의 항목은 일관된 선택 모델을 따릅니다.

- 포함된 도구 모음에는 **문서별**명령만 포함하며 저장 과 같은 일반적인 명령은 포함되어 있지 않습니다.

- 범례는 지표 또는 워터마크로 표면에 나타날 수 있습니다.

- 사용자는 **도구 > 옵션** 페이지(공유 글꼴 및 색상 페이지 또는 편집기와 관련된 페이지)를 사용하여 글꼴/색상의 모양을 사용자 지정할 수 있어야 합니다.

#### <a name="reports"></a>보고서

- 보고서는 일반적으로 정보 전용이며 저장 모델에 참여하지 않습니다. 그러나 다른 관련 정보 또는 확장 및 축소 하는 섹션에 대 한 링크 와 같은 상호 작용을 포함될 수 있습니다.

- 표면의 대부분의 명령은 버튼이 아닌 하이퍼링크여야 합니다.

- 레이아웃에는 헤더가 포함되어야 하며 표준 보고서 레이아웃 지침을 따라야 합니다.

#### <a name="dashboards"></a>대시보드

- 대시보드에는 상호 작용 모델 자체가 없지만 다양한 다른 도구를 제공하는 수단으로 사용됩니다.

- 저장 모델에는 참여하지 않습니다.

- 사용자는 편집기를 활성화하고 컨트롤을 통해 탭하거나 표준 니모닉을 사용하여 키보드만 사용하여 컨트롤과 상호 작용할 수 있어야 합니다.

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a>대화

### <a name="introduction"></a>소개
Visual Studio의 대화 상자는 일반적으로 사용자 작업의 개별 단위 하나를 지원한 다음 해제해야 합니다.

대화 상자가 필요하다고 결정한 경우 기본 설정 순서대로 세 가지 를 선택할 수 있습니다.

1. 기능을 Visual Studio의 공유 대화 상자 중 하나에 통합합니다.

2. 기존 유사한 대화 상자에 있는 패턴을 사용하여 사용자 고유의 대화 상자를 만듭니다.

3. 상호 작용 및 레이아웃 지침에 따라 새 대화 상자를 만듭니다.

이 섹션에서는 Visual Studio 워크플로 및 대화 디자인에 대한 일반적인 규칙 내에서 올바른 대화 상자 패턴을 선택하는 방법에 대해 설명합니다.

### <a name="themes"></a>테마
Visual Studio의 대화 상자는 두 가지 기본 스타일 중 하나를 따릅니다.

#### <a name="standard-unthemed"></a>표준(테마가 없는)
대부분의 대화 상자는 표준 유틸리티 대화 상자이며 테마를 해제해야 합니다. 일반적인 컨트롤을 다시 템플릿으로 만들거나 양식에 일치시키는 "최신" 단추 또는 컨트롤을 만들려고 시도하지 마십시오. 컨트롤 및 크롬 [모양은 대화 상자에 대한 표준 Windows 데스크톱 상호 작용 지침을 따릅니다.](/windows/desktop/uxguide/win-dialog-box)

#### <a name="themed"></a>테마
특수 "서명" 대화 상자를 테마로 할 수 있습니다. 테마 대화 상자는 스타일과 관련된 몇 가지 특별한 상호 작용 패턴을 가지고 뚜렷한 모양을 가지고 있습니다. 다음 요구 사항을 충족하는 경우에만 대화 상자를 테마로 지정합니다.

- 대화 상자는 자주 보거나 많은 사용자(예: **새 프로젝트** 대화 상자)에서 자주 보거나 사용하는 일반적인 환경입니다.

- 대화 상자에는 눈에 띄는 제품 브랜드 요소(예: **계정 설정** 대화 상자)가 포함되어 있습니다.

- 대화 상자는 다른 테마 대화 상자(예: **연결된 서비스 추가** 대화 상자)를 포함하는 더 큰 흐름의 필수적인 부분으로 나타납니다.

- 대화 상자는 제품 버전을 홍보하거나 차별화하는 데 전략적역할을 하는 경험의 중요한 부분입니다.

테마 대화 상자를 만들 때 적절한 환경 색상을 사용하고 올바른 레이아웃 및 상호 작용 패턴을 따릅니다. (비주얼 [스튜디오에 대한 레이아웃](../../extensibility/ux-guidelines/layout-for-visual-studio.md)을 참조하십시오.)

### <a name="dialog-design"></a>대화 상자 디자인
잘 설계된 대화 상자는 다음 요소를 고려합니다.

- 지원되는 사용자 작업

- 대화 상자 텍스트 스타일, 언어 및 용어

- 제어 선택 및 UI 규칙

- 시각적 레이아웃 사양 및 제어 정렬

- 키보드 액세스

#### <a name="content-organization"></a>콘텐츠 조직
다음과 같은 기본 대화 상자 유형 간의 차이점을 고려하십시오.

- [간단한 대화 상자는](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 단일 모달 창에 컨트롤을 표시합니다. 프레젠테이션에는 필드 선택기 또는 아이콘 막대를 비롯한 복잡한 컨트롤 패턴의 변형이 포함될 수 있습니다.

- [계층화된 대화 상자는](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs) 단일 UI가 여러 컨트롤 그룹으로 구성될 때 화면 실체를 최대한 활용합니다. 대화 상자의 그룹은 탭 컨트롤, 탐색 목록 컨트롤 또는 단추를 통해 "계층화"되므로 사용자는 특정 순간에 볼 그룹을 선택할 수 있습니다.

- [마법사는](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) 작업 완료를 향한 논리적 단계 순서를 통해 사용자를 안내하는 데 유용합니다. 일련의 선택 사항은 순차 패널에서 제공되며, 때로는 이전 패널에서 선택한 부분에 따라 다른 워크플로("분기")를 도입하기도 합니다.

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>간단한 대화 상자
간단한 대화 상자는 단일 모달 창에서 컨트롤을 표시 합니다. 이 프레젠테이션에는 필드 선택기와 같은 복잡한 컨트롤 패턴의 변형이 포함될 수 있습니다. 간단한 대화 상자의 경우 복잡한 제어 그룹화에 필요한 특정 레이아웃뿐만 아니라 표준 일반 레이아웃을 따릅니다.

![>강력한 이름 만들기 키는 Visual Studio에서 간단한 대화 상자의 예입니다.](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />강력한 이름 만들기 키는 Visual Studio에서 간단한 대화 상자의 예입니다.

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>계층화된 대화 상자
계층화된 대화 상자에는 탭, 대시보드 및 포함된 트리가 포함됩니다. 단일 UI에서 제공되는 여러 컨트롤 그룹이 있을 때 부동산을 최대화하는 데 사용됩니다. 그룹은 사용자가 한 번에 볼 그룹을 선택할 수 있도록 계층화됩니다.

가장 간단한 경우 그룹화 간에 전환하는 메커니즘은 탭 컨트롤입니다. 몇 가지 대안을 사용할 수 있습니다. 가장 적합한 스타일을 선택하는 방법은 우선 순위 지정 및 계층화를 참조하십시오.

**도구 &gt; 옵션** 대화 상자는 포함된 트리를 사용하는 계층화된 대화 상자의 예입니다.

![도구 > 옵션은 Visual Studio의 계층화된 대화 상자의 예입니다.](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "02_ToolsOptions 0704-02_ToolsOptions")<br />도구 > 옵션은 Visual Studio의 계층화된 대화 상자의 예입니다.

#### <a name="wizards"></a><a name="BKMK_Wizards"></a>마법사
마법사는 작업을 완료할 때 논리적 단계 순서를 통해 사용자를 안내하는 데 유용합니다. 일련의 선택 사항은 순차 패널에서 제공되며 사용자는 다음 단계로 진행하기 전에 각 단계를 계속 해야 합니다. 충분한 기본값을 사용할 수 있게 되면 **완료** 단추가 활성화됩니다.

 모달 마법사는 다음과 같은 작업에 사용됩니다.

- 사용자 선택에 따라 다른 경로가 제공되는 분기 포함

- 후속 단계가 이전 단계의 사용자 입력에 종속되는 단계 간의 종속성을 포함합니다.

- UI를 사용하여 제공된 선택 사항과 각 단계에서 가능한 결과를 설명하는 데 충분히 복잡합니다.

- 변경 내용이 커밋되기 전에 전체 단계를 완료해야 하는 트랜잭션입니다.

### <a name="common-conventions"></a>일반적인 규칙
대화 상자를 사용하여 최적의 디자인과 기능을 얻으려면 대화 상자 크기, 위치, 표준, 제어 구성 및 정렬, UI 텍스트, 제목 표시줄, 제어 단추 및 액세스 키에 대한 다음 규칙을 따릅니다.

레이아웃별 지침은 Visual [Studio에 대한 레이아웃을](../../extensibility/ux-guidelines/layout-for-visual-studio.md)참조하십시오.

#### <a name="size"></a>크기
대화 상자는 최소 1024x768 화면 해상도 내에 있어야 하며 초기 대화 상자 크기는 900x700픽셀을 초과해서는 안 됩니다. 대화 상자는 쉽게 할 수 있지만 필수 사항은 아닙니다.

식의 대화 상자에는 두 가지 권장 사항이 있습니다.

1. 최소 크기는 클리핑 없이 컨트롤 집합에 최적화하고 적절한 지역화 증가를 수용하도록 조정하는 대화 상자에 대해 정의됩니다.

2. 사용자 크기가 세션간 으로 유지되도록 합니다. 예를 들어 사용자가 대화 상자를 150%로 확장하면 대화 상자의 후속 실행이 150%로 표시됩니다.

#### <a name="position"></a>위치
대화 상자는 처음 시작할 때 IDE 내에서 중앙에 나타나야 합니다. 재조정 불가능한 대화 상자의 마지막 위치는 지속될 필요가 없으므로 후속 실행 중심으로 표시됩니다.

크기를 조정할 수 있는 대화 상자의 경우 이후 시작 시 크기를 유지해야 합니다. 재지정 가능한 모달 대화 상자의 경우 위치를 지속할 필요가 없습니다. IDE 가운데에 표시하면 사용자의 디스플레이 구성이 변경될 때 대화 상자가 예기치 않거나 사용할 수 없는 위치에 나타날 가능성을 방지합니다.

재배치할 수 있는 모덜리스 대화 상자의 경우 대화 상자가 더 큰 워크플로의 필수적인 부분으로 자주 사용될 수 있기 때문에 후속 시작 시 사용자의 위치를 유지해야 합니다.

대화 상자가 다른 대화 상자를 생성해야 하는 경우 맨 위 대화 상자가 부모에서 오른쪽으로 계단식으로 배열되어 사용자가 새 곳으로 이동했다는 것을 분명히 해야 합니다.

#### <a name="modality"></a>형식
모달이 된다는 것은 사용자가 계속하기 전에 대화를 완료하거나 취소해야 한다는 것을 의미합니다. 모달 대화 상자는 사용자가 환경의 다른 부분과 상호 작용하는 것을 차단하므로 기능의 작업 흐름은 가능한 한 아껴서 사용해야 합니다. 모달 작업이 필요한 경우 Visual Studio에는 기능을 통합할 수 있는 여러 공유 대화 상자가 있습니다. 새 대화 상자를 만들어야 하는 경우 유사한 기능이 있는 기존 대화 상자의 상호 작용 패턴을 따릅니다.

사용자가 새 코드를 작성하는 동안 **찾기** 및 **바꾸기와** 같은 두 가지 작업을 한 번에 수행해야 하는 경우 사용자가 쉽게 전환할 수 있도록 대화 상자가 모더니어여야 합니다. Visual Studio는 일반적으로 이러한 종류의 편집기 지원 연결된 작업에 도구 창을 사용합니다.

#### <a name="control-configuration"></a>제어 구성
Visual Studio에서 동일한 작업을 수행하는 기존 컨트롤 구성과 일치합니다.

#### <a name="title-bars"></a>제목 표시줄

- 제목 표시줄의 텍스트는 해당 명령 표시줄을 시작한 명령의 이름을 반영해야 합니다.

- 대화 상자 제목 표시줄에는 아이콘을 사용할 수 없습니다. 시스템에 필요한 경우 Visual Studio 로고를 사용합니다.

- 대화 상자에는 단추를 최소화하거나 최대화할 수 없습니다.

- 제목 표시줄의 도움말 버튼이 더 이상 사용되지 않습니다. 새 대화 상자에 추가하지 마십시오. 존재할 때 는 작업과 개념적으로 관련된 도움말 항목을 시작해야 합니다.

  ![Visual Studio 대화 상자의 제목 표시줄에 대한 지침 사양](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Visual Studio 대화 상자의 제목 표시줄에 대한 지침 사양

#### <a name="control-buttons"></a>제어 버튼
일반적으로 **확인**, **취소**및 **도움말** 단추는 대화 상자의 오른쪽 아래 모서리에 가로로 정렬되어야 합니다. 대화 상자에 컨트롤 단추와 시각적으로 혼동을 줄 수 있는 대화 상자 의 맨 아래에 여러 개의 다른 단추가 있는 경우 대체 수직 스택이 허용됩니다.

![Visual Studio 대화 상자의 제어 단추에 허용되는 구성](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "04_ControlButtonConfig 0704-")<br />Visual Studio 대화 상자의 제어 단추에 허용되는 구성

대화 상자에는 기본 제어 버튼이 포함되어야 합니다. 기본값으로 사용할 최상의 명령을 결정하려면 다음 옵션(우선 순위 순으로 나열됨)에서 선택합니다.

- 가장 안전하고 가장 안전한 명령을 기본값으로 선택합니다. 즉, 데이터 손실을 방지하고 의도하지 않은 시스템 액세스를 방지할 가능성이 가장 높은 명령을 선택합니다.

- 데이터 손실 및 보안이 요인이 아닌 경우 편의에 따라 기본 명령을 선택합니다. 가장 가능성이 높은 명령을 기본값으로 포함하면 대화 상자가 자주 또는 반복적인 작업을 지원할 때 사용자의 워크플로가 향상됩니다.

기본 명령에 대해 영구적으로 파괴적인 작업을 선택하지 마십시오. 이러한 명령이 있는 경우 대신 더 안전한 명령을 기본값으로 선택합니다.

#### <a name="access-keys"></a>액세스 키
**확인,** **취소**또는 **도움말** 단추에 액세스 키를 사용하지 마십시오. 이러한 단추는 기본적으로 바로 가기 키에 매핑됩니다.

| 단추 이름 | 바로 가기 키 |
| --- | --- |
| 확인 | Enter |
| 취소 | Esc |
| 도움말 | F1 |

#### <a name="imagery"></a>이미지
대화 상자에서 이미지를 아껴서 사용합니다. 대화 상자에 큰 아이콘을 사용하지 마십시오. 경고 아이콘이나 상태 애니메이션과 같이 사용자에게 메시지를 전달하는 데 중요한 부분인 경우에만 이미지를 사용합니다.

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>우선 순위 지정 및 계층화

#### <a name="prioritizing-your-ui"></a>UI 우선 순위 지정
특정 UI 요소를 최전방에 배치하고 보다 고급 동작 및 옵션(모호한 명령 포함)을 대화 상자에 배치해야 할 수 있습니다. 대화 상자가 표시될 때 텍스트 레이블이 있는 UI에서 기본적으로 표시하도록 하여 일반적으로 사용되는 기능을 최전선에 가져옵니다.

#### <a name="layering-your-ui"></a>UI 계층화
대화 상자가 필요하다고 판단되었지만 사용자에게 제시하려는 관련 기능이 간단한 대화 상자에 표시될 수 있는 것 이상으로 진행된다고 판단되면 UI를 계층화해야 합니다. Visual Studio에서 사용하는 가장 일반적인 계층화 방법은 탭과 복도 또는 대시보드입니다. 경우에 따라 확장 및 축소할 수 있는 영역이 적절할 수 있습니다. 적응형 UI는 일반적으로 Visual Studio에서는 권장되지 않습니다.

탭과 같은 컨트롤을 통해 UI를 계층화하는 여러 가지 방법에는 장점과 단점이 있습니다. 아래 목록을 검토하여 상황에 적합한 계층화 기술을 선택합니다.

##### <a name="tabbing"></a>탭 이동

| 스위칭 메커니즘 | 장점과 적절한 사용 | 단점 및 부적절한 사용 |
| --- | --- | --- |
| 탭 컨트롤 | 대화 상자를 관련 집합으로 논리적으로 그룹화<br /><br />대화 상자에서 관련 컨트롤의 5개 미만(또는 대화 상자에서 한 행에 맞는 탭 수) 페이지에 유용합니다.<br /><br />탭 레이블은 짧아야 합니다: 콘텐츠를 쉽게 식별할 수 있는 단어 하나 또는 두 개<br /><br />일반적인 시스템 대화 상자 스타일<br /><br />예: **파일 &gt; 탐색기 항목 속성** | 설명이 있는 짧은 레이블을 만드는 것은 어려울 수 있습니다.<br /><br />일반적으로 하나의 대화 상자에서 5개의 탭을 지나확장하지 않습니다.<br /><br />한 행에 탭이 너무 많은 경우 부적절한(대체 레이어링 기법 사용)<br /><br />확장 할 수 없습니다 |
| 사이드바 탐색 | 탭보다 더 많은 범주를 수용 할 수있는 간단한 스위칭 장치<br /><br />플랫 범주 목록(계층 구조 없음)<br /><br />확장 가능<br /><br />예: **사용자 지정... 명령 &gt; 추가** | 3개 미만의 그룹이 있는 경우 가로 공간을 잘 사용하지 않습니다.<br /><br />드롭다운에 더 적합한 작업 |
| 트리 컨트롤 | 무제한 카테고리 허용<br /><br />범주의 그룹화 및/또는 계층 구조 허용<br /><br />확장 가능<br /><br />예: ** &gt; 도구 옵션** | 중첩된 계층구조로 인해 과도한 가로 스크롤이 발생할 수 있습니다.<br /><br />비주얼 스튜디오는 나무 보기의 과잉을 가지고 |
| 마법사 | 작업 기반 순차적 단계를 통해 사용자를 안내하여 작업 완료에 도움이 됩니다.<br /><br />사용자가 작업을 완료하기 위해 여러 편집기 와 도구 창을 사용해야 하는 경우와 같이 작업이 Ui 경계를 넘을 때 유용합니다.<br /><br />작업에 분기가 필요한 경우 유용합니다.<br /><br />작업에 단계 간 종속성이 포함된 경우 유용합니다.<br /><br />하나의 결정 포크가 있는 여러 유사한 작업을 하나의 대화 상자에 표시하여 서로 다른 유사한 대화 상자의 수를 줄이는 데 유용합니다. | 순차워크플로우가 필요하지 않은 작업에 적합하지 않습니다.<br /><br />사용자가 너무 많은 단계로 마법사에 의해 압도되고 혼동 될 수 있습니다.<br /><br />마법사는 본질적으로 화면 부동산이 제한되어 있습니다. |

##### <a name="hallways-or-dashboards"></a>복도 또는 대시보드
복도 및 대시보드는 다른 대화 상자및 창의 시작 지점역할을 하는 대화 상자 또는 패널입니다. 잘 설계된 "복도"는 가장 일반적인 옵션, 명령 및 설정만 즉시 표시하므로 사용자가 일반적인 작업을 쉽게 수행할 수 있습니다. 실제 복도가 뒤에 있는 방에 접근할 수 있는 출입구를 제공하는 것처럼, 여기서는 덜 일반적인 UI가 메인 복도에서 액세스할 수 있는 관련 기능의 별도의 "룸"(종종 다른 대화 상자)으로 수집됩니다.

또는 덜 일반적인 기능을 별도의 위치로 리팩터링하는 대신 단일 컬렉션에서 사용 가능한 모든 기능을 제공하는 UI는 단순히 대시보드일 뿐입니다.

![Outlook에서 추가 UI를 노출하기위한 복도 개념](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />Outlook에서 추가 UI를 노출하기위한 복도 개념

##### <a name="adaptive-ui"></a>적응형 UI
사용 또는 사용자의 자체 보고 환경을 기반으로 UI를 표시하거나 숨기는 것은 다른 부분을 숨기면서 필요한 UI를 표시하는 또 다른 방법입니다. UI를 표시하거나 숨길 시기를 결정하는 알고리즘은 까다로울 수 있으며 일부 사례에서는 항상 규칙이 잘못될 수 있기 때문에 Visual Studio에서는 이 방법을 사용하지 않는 것이 좋습니다.

## <a name="projects"></a><a name="BKMK_Projects"></a>프로젝트

### <a name="projects-in-the-solution-explorer"></a>솔루션 탐색기의 프로젝트
대부분의 프로젝트는 참조 기반, 디렉터리 기반 또는 혼합으로 분류됩니다. 세 가지 유형의 프로젝트 모두 솔루션 탐색기에서 동시에 지원됩니다. 프로젝트 작업에서 사용자 환경의 루트는 이 창 내에서 이루어집니다. 서로 다른 프로젝트 노드가 참조, 디렉터리 또는 혼합 모드 형식 프로젝트이지만 프로젝트별 사용자 패턴으로 분기하기 전에 시작점으로 적용해야 하는 일반적인 상호 작용 패턴이 있습니다.

프로젝트는 항상 다음을 수행해야 합니다.

- 프로젝트 폴더를 추가하여 프로젝트 내용을 구성할 수 있는 기능 지원

- 프로젝트 지속성에 대한 일관된 모델 유지

또한 프로젝트는 다음에 대한 일관된 상호 작용 모델을 유지해야 합니다.

- 프로젝트 항목 제거

- 문서 저장

- 프로젝트 속성 편집

- 대체 뷰에서 프로젝트 편집

- 끌어서 놓기 연산

### <a name="drag-and-drop-interaction-model"></a>끌어서 놓기 상호 작용 모델
프로젝트는 일반적으로 자신을 참조 기반(저장소의 프로젝트 항목에 대한 참조만 지속 가능), 디렉터리 기반(프로젝트 계층 내에 물리적으로 저장된 프로젝트 항목만 유지가능) 또는 혼합(참조 또는 물리적 항목을 지속할 수 있음)으로 분류합니다. IDE는 **솔루션 탐색기**내에서 세 가지 유형의 프로젝트를 동시에 수용합니다.

끌어서 놓기 관점에서 솔루션 **탐색기**내의 각 프로젝트 유형에 다음 특성이 적용되어야 합니다.

- **참조 기반 프로젝트:** 핵심은 프로젝트가 저장소의 항목에 대한 참조를 중심으로 드래그하고 있다는 것입니다. 참조 기반 프로젝트가 이동 작업의 소스역할을 하는 경우 프로젝트에서 항목에 대한 참조만 제거해야 합니다. 하드 드라이브에서 항목을 실제로 삭제하면 안 됩니다. 참조 기반 프로젝트가 이동(또는 복사) 작업의 대상으로 작용하는 경우 항목의 개인 복사본을 만들지 않고 원본 원본 항목에 대한 참조를 추가해야 합니다.

- **디렉터리 기반 프로젝트:** 끌어서 놓기 관점에서 프로젝트는 참조가 아닌 실제 항목 주위로 드래그합니다. 디렉터리 기반 프로젝트가 이동 작업의 소스 역할을 하는 경우 하드 드라이브에서 실제 항목을 삭제하고 프로젝트에서 제거해야 합니다. 디렉터리 기반 프로젝트가 이동(또는 복사) 작업의 대상으로 작동하면 대상 위치에 소스 항목의 복사본을 만들어야 합니다.

- **혼합 대상 프로젝트:** 끌어서 놓기 관점에서 이러한 유형의 프로젝트의 동작은 드래그되는 항목의 특성(저장소의 항목에 대한 참조 또는 항목 자체)을 기반으로 합니다. 참조 및 물리적 항목에 대한 올바른 동작은 위에서 설명합니다.

**솔루션 탐색기에서**한 가지 유형의 프로젝트만 있는 경우 끌어서 놓기 작업이 간단합니다. 각 프로젝트 시스템에는 자체 끌어서 놓기 동작을 정의할 수 있으므로 예측 가능한 사용자 환경을 보장하기 위해 특정 지침(Windows 탐색기 끌어 놓기 동작에 따라)을 따라야 합니다.

- **솔루션 탐색기에서** 수정되지 않은 드래그 작업(Ctrl 또는 Shift 키가 모두 유지되지 않은 경우)은 이동 작업을 발생시켜야 합니다.

- 시프트 드래그 작업도 이동 작업을 발생시켜야 합니다.

- Ctrl-drag 작업으로 인해 복사 작업이 발생합니다.

- 참조 기반 및 혼합 프로젝트 시스템은 원본 항목에 링크(또는 참조)를 추가하는 개념을 지원합니다. 이러한 프로젝트가 끌어서 놓기 작업의 대상인 **경우(Ctrl + Shift가** 유지될 때) 프로젝트에 추가되는 항목에 대한 참조가 생성되어야 합니다.

모든 끌어서 놓기 작업이 참조 기반, 디렉터리 기반 및 혼합 프로젝트의 조합에서 합리적이지는 않습니다. 특히 소스 디렉터리 기반 프로젝트는 이동이 완료되면 소스 항목을 삭제해야 하기 때문에 디렉터리 기반 원본 프로젝트와 참조 기반 대상 프로젝트 간에 이동 작업을 허용하는 척하는 것이 문제가 됩니다. 그러면 대상 참조 기반 프로젝트가 삭제된 항목에 대한 참조로 끝납니다.

또한 대상 참조 기반 프로젝트가 원본 항목의 독립적인 복사본을 만들지 않아야 하기 때문에 이러한 유형의 프로젝트 간에 복사 작업을 허용하는 척하는 것은 오해의 소지가 있습니다. 마찬가지로 디렉터리 기반 프로젝트에서 참조를 지속할 수 없으므로 Ctrl + Shift 드래그를 디렉터리 기반 대상 프로젝트로 드래그할 수 없습니다. 끌어서 놓기 작업이 지원되지 않는 경우 IDE는 드롭을 허용하지 않고 사용자에게 드롭 없음 커서(아래 포인터 표에 표시됨)를 표시해야 합니다.

끌어서 놓기 동작을 제대로 구현하려면 드래그의 소스 프로젝트가 특성을 대상 프로젝트에 전달해야 합니다. (예를 들어, 참조 또는 디렉토리 기반입니까?) 이 정보는 소스에서 제공하는 클립보드 형식으로 표시됩니다. 드래그(또는 클립보드 복사 작업)의 소스로서 프로젝트는 `CF_VSREFPROJECTITEMS` 참조 `CF_VSSTGPROJECTITEMS` 기반인지 디렉터리 기반인지에 따라 프로젝트가 각각 제공되어야 합니다. 두 형식 모두 파일 이름이 아닌 문자열 목록이 `CF_HDROP` `NULL` `Projref` `IVsSolution::GetProjrefOfItem` 반환되거나 `::GetProjrefOfProject` 적절하게 반환되는 문자열 목록이라는 점을 제외하면 Windows 형식과 유사한 동일한 데이터 콘텐츠를 갖습니다.

드롭(또는 클립보드 붙여넣기 작업)의 대상으로 서, `CF_VSREFPROJECTITEMS` 프로젝트는 `CF_VSSTGPROJECTITEMS`둘 다 허용 해야 하 고 드래그 앤 드롭 작업의 정확한 처리 대상 프로젝트 및 소스 프로젝트의 특성에 따라 달라 집니다. 소스 프로젝트는 제공 여부에 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS`따라 그 특성을 선언합니다. 드롭의 대상은 자체 특성을 이해하므로 이동, 복사 또는 링크를 수행할지 여부를 결정할 수 있는 충분한 정보가 있습니다. 또한 사용자는 Ctrl, Shift 또는 Ctrl 및 Shift 키를 모두 눌러 드래그 앤 드롭 작업을 수행해야 하는 작업을 수정합니다. 놓기 대상이 해당 `DragEnter` 작업 및 `DragOver` 메서드에서 미리 수행할 작업을 적절하게 표시하는 것이 중요합니다. **솔루션 탐색기는** 소스 프로젝트와 대상 프로젝트가 동일한 프로젝트인지 여부를 자동으로 알고 있습니다.

Visual Studio의 인스턴스에서 프로젝트 항목을 드래그하는 경우(예: devenv.exe의 한 인스턴스에서 다른 인스턴스로)는 특별히 지원되지 않습니다. **또한 솔루션 탐색기는** 이 기능을 직접 사용하지 않도록 설정합니다.

사용자는 항상 항목을 선택하고 대상 위치로 드래그하고 항목을 삭제하기 전에 다음 마우스 포인터가 나타나는지 관찰하여 끌어서 놓기 작업의 효과를 확인할 수 있어야 합니다.

| 마우스 포인터 | 명령 | 설명 |
| :---: | --- | --- |
| ![마우스 "끌어 놓기 없음" 아이콘](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 드롭 없음 | 지정된 위치로 항목을 삭제할 수 없습니다. |
| ![마우스 "복사" 아이콘](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 복사 | 항목이 대상 위치로 복사됩니다. |
| ![마우스 "이동" 아이콘](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 이동 | 항목이 대상 위치로 이동됩니다. |
| ![마우스 "참조 추가" 아이콘](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 추가 참조 | 선택한 항목에 대한 참조가 대상 위치에 추가됩니다. |

#### <a name="reference-based-projects"></a>참조 기반 프로젝트
 다음 표에서는 참조된 대상 프로젝트에 대해 소스 항목 및 수정자 키의 특성에 따라 수행해야 하는 끌어서 놓기(잘라내기/복사/붙여넣기) 작업을 요약합니다.

| 한정자 | Category | 원본 항목: 참조/링크 | 소스 항목: 물리적 항목`CF_HDROP`또는 파일 시스템 ( ) |
| --- | --- | --- | --- |
| 수정자 없음 | 작업 | 이동 | 링크 |
| 수정자 없음 | 대상 | 원본 항목에 참조 추가 | 원본 항목에 참조 추가 |
| 수정자 없음 | 원본 | 원본 항목에 대한 참조 삭제 | 원래 항목 유지 |
| 수정자 없음 | 결과 | `DROPEFFECT_MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_LINK`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| 시프트+드래그 | 작업 | 이동 | 드롭 없음 |
| 시프트+드래그 | 대상 | 원본 항목에 참조 추가 | 드롭 없음 |
| 시프트+드래그 | 원본 | 원본 항목에 대한 참조 삭제 | 드롭 없음 |
| 시프트+드래그 | 결과 | `DROPEFFECT_MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | 드롭 없음 |
| Ctrl+드래그 | 작업 | 복사 | 드롭 없음 |
| Ctrl+드래그 | 대상 | 원본 항목에 참조 추가 | 드롭 없음 |
| Ctrl+드래그 | 원본 | 원본 항목에 대한 참조 유지 | 드롭 없음 |
| Ctrl+드래그 | 결과 | `DROPEFFECT_COPY`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | 드롭 없음 |
| Ctrl+시프트+드래그 | 작업 | 링크 | 링크 |
| Ctrl+시프트+드래그 | 대상 | 원본 항목에 참조 추가 | 원본 항목에 참조 추가 |
| Ctrl+시프트+드래그 | 원본 | 원본 항목에 대한 참조 유지 | 원래 항목 유지 |
| Ctrl+시프트+드래그 | 결과 | `DROPEFFECT_LINK`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_LINK`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| Ctrl+시프트+드래그 | 참고 | Windows 탐색기의 바로 가기에 대한 끌어서 놓기 동작과 동일합니다. ||
| 잘라내기/붙여넣기 | 작업 | 이동 | 링크 |
| 잘라내기/붙여넣기 | 대상 | 원본 항목에 참조 추가 | 원본 항목에 참조 추가 |
| 잘라내기/붙여넣기 | 원본 | 원본 항목에 대한 참조 유지|원래 항목 유지 |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 남아 있습니다. | 항목은 저장소의 원래 위치에 남아 있습니다. |
| 복사/붙여넣기 | 작업 | 복사 | 링크 |
| 복사/붙여넣기 | 원본 | 원본 항목에 참조 추가 | 원본 항목에 참조 추가 |
| 복사/붙여넣기 | 결과 | 원본 항목에 대한 참조 유지 | 원래 항목 유지 |
| 복사/붙여넣기 | 작업 | 항목은 저장소의 원래 위치에 남아 있습니다. | 항목은 저장소의 원래 위치에 남아 있습니다. |

#### <a name="directory-based-projects"></a>디렉터리 기반 프로젝트
다음 표에서는 소스 항목의 특성과 디렉터리 기반 대상 프로젝트에 대해 누른 수정자 키의 특성에 따라 수행해야 하는 끌어서 놓기(잘라내기/복사/붙여넣기) 작업을 요약합니다.

| 한정자 | Category | 원본 항목: 참조/링크 | 소스 항목: 물리적 항목`CF_HDROP`또는 파일 시스템 ( ) |
|-----------------|----------| - | - |
| 수정자 없음 | 작업 | 이동 | 이동 |
| 수정자 없음 | 대상 | 대상 위치에 항목 복사 | 대상 위치에 항목 복사 |
| 수정자 없음 | 원본 | 원본 항목에 대한 참조 삭제 | 원본 항목에 대한 참조 삭제 |
| 시프트+드래그 | 작업 | 이동 | 이동 |
| 시프트+드래그 | 대상 | 대상 위치에 항목 복사 | 대상 위치에 항목 복사 |
| 시프트+드래그 | 원본 | 원본 항목에 대한 참조 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 시프트+드래그 | 결과 | `DROPEFFECT_MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| Ctrl+드래그 | 작업 | 복사 | 복사 |
| Ctrl+드래그 | 대상 | 대상 위치에 항목 복사 | 대상 위치에 항목 복사 |
| Ctrl+드래그 | 원본 | 원본 항목에 대한 참조 유지 | 원본 항목에 대한 참조 유지 |
| Ctrl+드래그 | 결과 | `DROPEFFECT_COPY`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_COPY`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| Ctrl+시프트+드래그 | | 드롭 없음 | 드롭 없음 |
| 잘라내기/붙여넣기 | 작업 | 이동 | 이동 |
| 잘라내기/붙여넣기 | 대상 | 대상 위치에 항목 복사 | 대상 위치에 항목 복사 |
| 잘라내기/붙여넣기 | 원본 | 원본 항목에 대한 참조 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 남아 있습니다. | 저장소의 원래 위치에서 항목이 삭제됩니다. |
| 복사/붙여넣기 | 작업 | 복사 | 복사 |
| 복사/붙여넣기 | 대상 | 원본 항목에 참조 추가 | 대상 위치에 항목 복사 |
| 복사/붙여넣기 | 원본 | 원래 항목 유지 | 원래 항목 유지 |
| 복사/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 남아 있습니다. | 항목은 원래 위치 ins 저장에 남아 |

#### <a name="mixed-target-projects"></a>혼합 대상 프로젝트
다음 표에서는 소스 항목의 특성과 혼합 대상 프로젝트에 대해 누른 수정자 키의 특성에 따라 수행해야 하는 끌어서 놓기(잘라내기/복사/붙여넣기) 작업을 요약합니다.

| 한정자 | Category | 원본 항목: 참조/링크 | 소스 항목: 물리적 항목`CF_HDROP`또는 파일 시스템 ( ) |
| --- | --- | --- | --- |
| 수정자 없음 | 작업 | 이동 | 이동 |
| 수정자 없음 | 대상 | 원본 항목에 참조 추가 | 대상 위치에 항목 복사 |
| 수정자 없음 | 원본 | 원본 항목에 대한 참조 삭제 | 원본 항목에 대한 참조 삭제 |
| 수정자 없음 | 결과 | `DROPEFFECT_ MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_ MOVE`작업으로 `::Drop` 반환되고 저장소의 원래 위치에서 항목이 삭제됩니다. |
| 시프트+드래그 | 작업 | 이동 | 이동 |
| 시프트+드래그 | 대상 | 원본 항목에 참조 추가 | 대상 위치에 항목 복사 |
| 시프트+드래그 | 원본 | 원본 항목에 대한 참조 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 시프트+드래그 | 결과 | `DROPEFFECT_ MOVE`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_ MOVE`작업으로 `::Drop` 반환되고 저장소의 원래 위치에서 항목이 삭제됩니다. |
| Ctrl+드래그 | 작업 | 복사 | 복사 |
| Ctrl+드래그 | 대상 | 원본 항목에 참조 추가 | 대상 위치에 항목 복사 |
| Ctrl+드래그 | 원본 | 원본 항목에 대한 참조 유지 | 원래 항목 유지 |
| Ctrl+드래그 | 결과 | `DROPEFFECT_ COPY`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_ COPY`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| Ctrl+시프트+드래그 | 작업 | 링크 | 링크 |
| Ctrl+시프트+드래그 | 대상 | 원본 항목에 참조 추가 | 원본 원본 항목에 참조 추가 |
| Ctrl+시프트+드래그 | 원본 | 원본 항목에 대한 참조 유지 | 원래 항목 유지 |
| Ctrl+시프트+드래그 | 결과 | `DROPEFFECT_ LINK`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. | `DROPEFFECT_ LINK`작업으로 반환되고 `::Drop` 저장소의 원래 위치에 항목이 남아 있습니다. |
| 잘라내기/붙여넣기 | 작업 | 이동 | 이동 |
| 잘라내기/붙여넣기 | 대상 | 대상 위치에 항목 복사 | 대상 위치에 항목 복사 |
| 잘라내기/붙여넣기 | 원본 | 원본 항목에 대한 참조 삭제 | 원래 위치에서 항목을 삭제합니다. |
| 잘라내기/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 남아 있습니다. | 저장소의 원래 위치에서 항목이 삭제됩니다. |
| 복사/붙여넣기 | 작업 | 복사 | 복사 |
| 복사/붙여넣기 | 대상 | 원본 항목에 참조 추가 | 대상 위치에 항목 복사 |
| 복사/붙여넣기 | 원본 | 원래 항목 유지 | 원래 항목 유지 |
| 복사/붙여넣기 | 결과 | 항목은 저장소의 원래 위치에 남아 있습니다. | 항목은 저장소의 원래 위치에 남아 있습니다. |

**솔루션 탐색기에서**드래그를 구현할 때 이러한 세부 정보를 고려해야 합니다.

- 여러 선택 시나리오를 위해 디자인합니다.

- 파일 이름(전체 경로)은 대상 프로젝트 전체에서 고유해야 하거나 삭제를 허용해서는 안 됩니다.

- 폴더 이름은 삭제되는 수준에서 고유(대/소문자 구분)이어야 합니다.

- 드래그 시 열려 있거나 닫힌 파일 간에는 동작 차이가 있습니다(위의 시나리오에서는 언급되지 않음).

- 최상위 파일은 폴더의 파일과 약간 다르게 행동합니다.

또 다른 주의해야 할 문제는 열려 있는 디자이너 나 편집기항목에서 이동 작업을 처리하는 방법입니다. 예상 동작은 다음과 같습니다(모든 프로젝트 유형에 적용됩니다).

1. 열려 있는 편집기/디자이너에 저장되지 않은 변경 내용이 없는 경우 편집기/디자이너 창을 자동으로 닫아야 합니다.

2. 열려 있는 편집기/디자이너에 저장되지 않은 변경 내용이 있는 경우 드래그 소스는 드롭이 발생할 때까지 기다린 다음 다음과 유사한 프롬프트로 창을 닫기 전에 열려 있는 문서에서 커밋되지 않은 변경 내용을 저장하도록 사용자에게 요청해야 합니다.

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

이렇게 하면 대상이 복사본을 만들기 전에 진행 중인 작업을 저장할 수 있습니다. 이 처리를 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 사용하도록 새 메서드가 추가되었습니다.

그런 다음 대상이 저장소에 있는 항목의 상태를 복사합니다(사용자가 **아니요를**선택한 경우 편집기에서 저장되지 않은 변경 내용을 포함하지 않음). 대상이 복사(in)를 `IVsHierarchyDropDataSource::Drop`완료하면 소스에 이동 작업의 삭제 부분을 완료할 수 있는 `IVsHierarchyDropDataSource::OnDropNotify`기회가 제공됩니다.

저장되지 않은 변경 내용이 있는 모든 편집자는 열어 두어야 합니다. 저장되지 않은 변경 내용이 있는 문서의 경우 이동 작업의 복사 부분이 수행되지만 삭제 부분이 중단됩니다. 사용자가 **아니오를**선택할 때 여러 선택 시나리오에서 저장되지 않은 변경 내용이 있는 해당 문서는 닫거나 제거해서는 안 되지만 저장되지 않은 변경 내용이 없는 문서는 닫고 제거해야 합니다.
