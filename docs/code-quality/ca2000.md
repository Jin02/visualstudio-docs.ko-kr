---
title: 'CA2000: 범위를 벗어나기 전에 개체를 삭제하십시오.'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615579"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: 범위를 벗어나기 전에 개체를 삭제하십시오.

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|범주|Microsoft.Reliability|
|주요 변경 내용|비브레이킹|

## <a name="cause"></a>원인

<xref:System.IDisposable> 형식의 로컬 개체가 만들어지지만 개체에 대한 모든 참조가 범위를 벗어나기 전에 개체가 삭제되지 않습니다.

기본적으로 이 규칙은 전체 코드베이스를 분석하지만 이 규칙은 [구성 할 수 있습니다.](#configurability)

## <a name="rule-description"></a>규칙 설명

일회용 개체가 범위를 벗어나기 전에 명시적으로 삭제되지 않으면 가비지 수집기가 개체의 종료자를 실행하는 불확실한 시간에 개체가 삭제됩니다. 개체의 종료자가 실행되지 않도록 하는 예외적인 이벤트가 발생할 수 있으므로 대신 개체를 명시적으로 삭제해야 합니다.

### <a name="special-cases"></a>특수 사례

규칙 CA2000은 개체가 삭제되지 않은 경우에도 다음 형식의 로컬 개체에 대해 발생하지 않습니다.

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

이러한 형식 중 하나의 개체를 생성자에 전달한 다음 필드에 할당하면 새로 생성된 형식에 *대한 삭제 소유권 전송이* 표시됩니다. 즉, 새로 생성된 형식은 이제 개체를 삭제합니다. 코드에서 이러한 형식 중 하나의 개체를 생성자에게 전달하는 경우 해당 형식에 대한 모든 참조가 범위를 벗어나기 전에 개체가 삭제되지 않은 경우에도 CA2000 규칙 위반이 발생하지 않습니다.

## <a name="how-to-fix-violations"></a>위반 문제를 해결하는 방법

이 규칙의 위반을 해결하려면 해당 규칙에 대한 모든 참조가 범위를 벗어나기 전에 개체를 호출합니다. <xref:System.IDisposable.Dispose%2A>

(Visual[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) Basic)에서 [ `using` 문(Visual](/dotnet/csharp/language-reference/keywords/using-statement) Basic)을 <xref:System.IDisposable>사용하여 을 구현하는 개체를 래핑할 수 있습니다. 이러한 방식으로 래핑된 개체는 `using` 블록 끝에 자동으로 배치됩니다. 그러나 다음과 같은 상황은 `using` 문으로 처리해서는 안됩니다.

- 일회용 개체를 반환하려면 개체가 `try/finally` `using` 블록 외부의 블록에 생성되어야 합니다.

- `using` 문 생성자에서 일회용 개체의 멤버를 초기화하지 마십시오.

- 하나의 예외 처리기로 보호되는 생성자가 [ `using` 문의 수집 부분에](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)중첩되면 외부 생성자의 실패로 인해 중첩된 생성자가 만든 개체가 닫히지 않을 수 있습니다. 다음 예제에서는 <xref:System.IO.StreamReader> 생성자의 실패로 인해 개체가 <xref:System.IO.FileStream> 닫히지 않을 수 있습니다. CA2000은 이 경우 규칙 위반에 플래그를 표시합니다.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- 동적 개체는 그림자 개체를 사용하여 개체의 <xref:System.IDisposable> 삭제 패턴을 구현해야 합니다.

## <a name="when-to-suppress-warnings"></a>경고를 억제하는 경우

다음을 하지 않는 한 이 규칙에서 경고를 표시하지 마십시오.

- 개체에서 메서드를 호출했습니다. `Dispose`<xref:System.IO.Stream.Close%2A>
- 경고를 발생 시킨 메서드는 <xref:System.IDisposable> 개체를 래핑 하는 개체를 반환 합니다.
- 할당 메서드에는 소유권을 삭제할 수 없습니다. 즉, 개체를 삭제하는 책임은 메서드에서 생성된 다른 개체 또는 래퍼로 전송되어 호출자에게 반환됩니다.

## <a name="configurability"></a>구성 가능성

레거시 분석이 아닌 [FxCop 분석기에서](install-fxcop-analyzers.md) 이 규칙을 실행하는 경우 이 규칙에 대한 분석을 구성할 수 있습니다.

### <a name="excluded-symbol-names"></a>제외된 기호 이름

분석에서 제외할 코드베이스 부분을 구성할 수 있습니다. 예를 들어 명명된 `MyType`형식 내의 코드에서 규칙이 실행되지 않도록 지정하려면 프로젝트의 .editorconfig 파일에 다음 키 값 쌍을 추가합니다.

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

옵션 값에서 허용된 기호 이름 형식('|'로 구분됨):
  - 기호 이름만(포함된 형식 또는 네임스페이스에 관계없이 이름이 포함된 모든 기호 포함)
  - 기호의 [문서 ID 형식에](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)완전히 정규화된 이름입니다. 각 기호 이름에는 메서드의 "M:" 접두사, 형식의 "T:" 접두사, 네임스페이스의 "N:" 접두사 등과 같은 기호 종류 접두사가 필요합니다.
  - `.ctor`생성자 및 `.cctor` 정적 생성자용

예제:

| 옵션 값 | 요약 |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | 편집에서 'MyType'이라는 이름의 모든 기호와 일치합니다.
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | 편집에서 'MyType1' 또는 'MyType2'라는 이름의 모든 기호와 일치합니다.
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | 특정 메서드 'MyMethod'를 지정된 정규서명과 일치시다.
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | 특정 메서드 'MyMethod1' 및 'MyMethod2'를 각각의 정규 서명과 일치시다.

이 규칙, 모든 규칙 또는 이 범주의 모든 규칙(디자인)에 대해 이러한 옵션을 모두 구성할 수 있습니다. 자세한 내용은 [FxCop 분석기 구성을](configure-fxcop-analyzers.md)참조하십시오.

## <a name="related-rules"></a>관련 규칙

- [CA2213: 삭제 가능한 필드는 삭제해야 합니다.](../code-quality/ca2213.md)
- [CA2202: 개체를 여러 번 삭제하지 마십시오.](../code-quality/ca2202.md)

## <a name="example"></a>예제

일회용 개체를 반환하는 메서드를 구현하는 경우 catch 블록 없이 try/finally 블록을 사용하여 개체가 삭제되었는지 확인합니다. try/finally 블록을 사용 하 여 오류 지점에서 예외를 발생 하도록 허용 하 고 개체가 삭제 되어 있는지 확인 합니다.

OpenPort1 메서드에서 ISerializable 개체 직렬 포트를 여는 호출 또는 SomeMethod에 대 한 호출이 실패할 수 있습니다. 이 구현에서 CA2000 경고가 발생합니다.

OpenPort2 메서드에서 두 개의 SerialPort 개체가 선언되고 null로 설정됩니다.

- `tempPort`는 메서드 작업이 성공하는지 테스트하는 데 사용됩니다.

- `port`을 사용하며 메서드의 반환 값에 사용됩니다.

블록에서 `tempPort` `try` 생성되고 열리며 다른 필요한 작업은 동일한 `try` 블록에서 수행됩니다. `try` 블록의 끝에서 열린 포트는 반환될 `port` 개체에 할당되고 개체가 `tempPort` `null`로 설정됩니다.

블록은 `finally` `tempPort`의 값을 확인합니다. null이 아닌 경우 메서드의 작업이 실패하고 `tempPort` 리소스가 해제되었는지 확인하기 위해 닫힙니다. 반환된 포트 개체에는 메서드의 작업이 성공한 경우 열린 SerialPort 개체가 포함되거나 작업이 실패하면 null이 됩니다.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>예제

기본적으로 Visual Basic 컴파일러에는 모든 산술 연산자가 오버플로를 검사합니다. 따라서 모든 Visual Basic 산술 연산 <xref:System.OverflowException>은 을 throw할 수 있습니다. 이로 인해 CA2000과 같은 규칙에서 예기치 않은 위반이 발생할 수 있습니다. 예를 들어 다음 CreateReader1 함수는 Visual Basic 컴파일러가 StreamReader를 삭제하지 않도록 하는 예외를 throw할 수 있는 추가에 대한 오버플로 검사 명령을 내보내므로 CA2000 위반을 생성합니다.

이 문제를 해결하려면 프로젝트의 Visual Basic 컴파일러에서 오버플로 검사 내보낸을 사용하지 않도록 설정하거나 다음 CreateReader2 함수에서와 같이 코드를 수정할 수 있습니다.

오버플로 검사의 내보낸값을 사용하지 않으려면 솔루션 탐색기에서 프로젝트 이름을 마우스 오른쪽 단추로 클릭한 다음 **속성을**클릭합니다. **컴파일을**클릭하고 **고급 컴파일 옵션을**클릭한 다음 **정수 오버플로 검사 제거를**선택합니다.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>참고 항목

- <xref:System.IDisposable>
- [삭제 패턴](/dotnet/standard/design-guidelines/dispose-pattern)
